<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Hashing to Elliptic Curves</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font: 13.5px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Elliptic curves">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Terminology">
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Encoding">
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Serialization">
<link href="#rfc.section.2.2.3" rel="Chapter" title="2.2.3 Random Oracle">
<link href="#rfc.section.3" rel="Chapter" title="3 Utility Functions">
<link href="#rfc.section.4" rel="Chapter" title="4 Hashing to a Finite Field">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Implementation">
<link href="#rfc.section.5" rel="Chapter" title="5 Deterministic Encodings">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Interface">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Notation">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Clearing Cofactor">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Encodings for Weierstrass curves">
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Icart Method">
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Shallue-Woestijne-Ulas Method">
<link href="#rfc.section.5.4.3" rel="Chapter" title="5.4.3 Simplified SWU Method">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Encodings for Montgomery curves">
<link href="#rfc.section.5.5.1" rel="Chapter" title="5.5.1 Elligator2 Method">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 Encodings for twisted Edwards curves">
<link href="#rfc.section.5.6.1" rel="Chapter" title="5.6.1 Elligator2 Method">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 Encodings for Supersingular curves">
<link href="#rfc.section.5.7.1" rel="Chapter" title="5.7.1 Boneh-Franklin Method">
<link href="#rfc.section.5.7.2" rel="Chapter" title="5.7.2 Elligator2A0 Method">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 Encodings for Pairing-Friendly curves">
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 Fouque-Tibouchi Method">
<link href="#rfc.section.6" rel="Chapter" title="6 Random Oracles">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Interface">
<link href="#rfc.section.7" rel="Chapter" title="7 Suites for Hashing">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 Security Considerations">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.section.11" rel="Chapter" title="11 Contributors">
<link href="#rfc.references" rel="Chapter" title="12 Normative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Related Work">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Probabilistic Encoding">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Naive Encoding">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 Deterministic Encoding">
<link href="#rfc.appendix.B" rel="Chapter" title="B Try-and-Increment Method">
<link href="#rfc.appendix.C" rel="Chapter" title="C Sample Code">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Icart Method">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Shallue-Woestijne-Ulas Method">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Simplified SWU Method">
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Boneh-Franklin Method">
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Fouque-Tibouchi Method">
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Elligator2 Method">
<link href="#rfc.appendix.D" rel="Chapter" title="D Test Vectors">
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Elligator2 to Curve25519">
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Icart to P-384">
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 SWU to P-256">
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 Simple SWU to P-256">
<link href="#rfc.appendix.D.5" rel="Chapter" title="D.5 Boneh-Franklin to P-503">
<link href="#rfc.appendix.D.6" rel="Chapter" title="D.6 Fouque-Tibouchi to BN256">
<link href="#rfc.appendix.D.7" rel="Chapter" title="D.7 Sample hash2base">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Faz-Hernandez, A., Scott, S., Sullivan, N., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-irtf-cfrg-hash-to-curve-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-04-26" />
  <meta name="dct.abstract" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an Elliptic Curve." />
  <meta name="description" content="This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an Elliptic Curve." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Faz-Hernandez</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">S. Scott</td>
</tr>
<tr>
<td class="left">Expires: October 28, 2019</td>
<td class="right">Cornell Tech</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">N. Sullivan</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Cloudflare</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">C. Wood</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Apple Inc.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">April 26, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Hashing to Elliptic Curves<br />
  <span class="filename">draft-irtf-cfrg-hash-to-curve-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document specifies a number of algorithms that may be used to encode or hash an arbitrary string to a point on an Elliptic Curve.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on October 28, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Background</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Elliptic curves</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Terminology</a>
</li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Encoding</a>
</li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Serialization</a>
</li>
<li>2.2.3.   <a href="#rfc.section.2.2.3">Random Oracle</a>
</li>
</ul></ul><li>3.   <a href="#rfc.section.3">Utility Functions</a>
</li>
<li>4.   <a href="#rfc.section.4">Hashing to a Finite Field</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Implementation</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Deterministic Encodings</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Interface</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Notation</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Clearing Cofactor</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Encodings for Weierstrass curves</a>
</li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Icart Method</a>
</li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Shallue-Woestijne-Ulas Method</a>
</li>
<li>5.4.3.   <a href="#rfc.section.5.4.3">Simplified SWU Method</a>
</li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Encodings for Montgomery curves</a>
</li>
<ul><li>5.5.1.   <a href="#rfc.section.5.5.1">Elligator2 Method</a>
</li>
</ul><li>5.6.   <a href="#rfc.section.5.6">Encodings for twisted Edwards curves</a>
</li>
<ul><li>5.6.1.   <a href="#rfc.section.5.6.1">Elligator2 Method</a>
</li>
</ul><li>5.7.   <a href="#rfc.section.5.7">Encodings for Supersingular curves</a>
</li>
<ul><li>5.7.1.   <a href="#rfc.section.5.7.1">Boneh-Franklin Method</a>
</li>
<li>5.7.2.   <a href="#rfc.section.5.7.2">Elligator2A0 Method</a>
</li>
</ul><li>5.8.   <a href="#rfc.section.5.8">Encodings for Pairing-Friendly curves</a>
</li>
<ul><li>5.8.1.   <a href="#rfc.section.5.8.1">Fouque-Tibouchi Method</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Random Oracles</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Interface</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Suites for Hashing</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">Security Considerations</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.section.11">Contributors</a>
</li>
<li>12.   <a href="#rfc.references">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">Related Work</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Probabilistic Encoding</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Naive Encoding</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">Deterministic Encoding</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Try-and-Increment Method</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Sample Code</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Icart Method</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Shallue-Woestijne-Ulas Method</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">Simplified SWU Method</a>
</li>
<li>C.4.   <a href="#rfc.appendix.C.4">Boneh-Franklin Method</a>
</li>
<li>C.5.   <a href="#rfc.appendix.C.5">Fouque-Tibouchi Method</a>
</li>
<li>C.6.   <a href="#rfc.appendix.C.6">Elligator2 Method</a>
</li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Test Vectors</a>
</li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Elligator2 to Curve25519</a>
</li>
<li>D.2.   <a href="#rfc.appendix.D.2">Icart to P-384</a>
</li>
<li>D.3.   <a href="#rfc.appendix.D.3">SWU to P-256</a>
</li>
<li>D.4.   <a href="#rfc.appendix.D.4">Simple SWU to P-256</a>
</li>
<li>D.5.   <a href="#rfc.appendix.D.5">Boneh-Franklin to P-503</a>
</li>
<li>D.6.   <a href="#rfc.appendix.D.6">Fouque-Tibouchi to BN256</a>
</li>
<li>D.7.   <a href="#rfc.appendix.D.7">Sample hash2base</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many cryptographic protocols require a procedure which maps arbitrary input, e.g., passwords, to points on an elliptic curve (EC). Prominent examples include Simple Password Exponential Key Exchange <a href="#Jablon96" class="xref">[Jablon96]</a>, Password Authenticated Key Exchange <a href="#BMP00" class="xref">[BMP00]</a>, Identity-Based Encryption <a href="#BF01" class="xref">[BF01]</a> and Boneh-Lynn-Shacham signatures <a href="#BLS01" class="xref">[BLS01]</a>.</p>
<p id="rfc.section.1.p.2">Unfortunately for implementors, the precise mapping which is suitable for a given scheme is not necessarily included in the description of the protocol.  Compounding this problem is the need to pick a suitable curve for the specific protocol.</p>
<p id="rfc.section.1.p.3">This document aims to address this lapse by providing a thorough set of recommendations across a range of implementations, and curve types. We provide implementation and performance details for each mechanism, along with references to the security rationale behind each recommendation and guidance for applications not yet covered.</p>
<p id="rfc.section.1.p.4">Each algorithm conforms to a common interface, i.e., it maps a bitstring {0, 1}^* to a point on an elliptic curve E. For each variant, we describe the requirements for E to make it work. Sample code for each variant is presented in the appendix.  Unless otherwise stated, all elliptic curve points are assumed to be represented as affine coordinates, i.e., the pair (x, y) denotes a point on an elliptic curve.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#requirements" id="requirements">Requirements</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#elliptic-curves" id="elliptic-curves">Elliptic curves</a>
</h1>
<p id="rfc.section.2.1.p.1">The following is a brief definition of elliptic curves, with an emphasis on defining important parameters and their relation to encoding.</p>
<p id="rfc.section.2.1.p.2">Let F be the finite field GF(q) of prime characteristic p.  For most applications, F is a prime field, in which case q=p, otherwise q=p^m for an integer m&gt;1.</p>
<p id="rfc.section.2.1.p.3">Elliptic curves can be represented by equations of different standard forms, including, but not limited to Weierstrass, Montgomery, and Edwards. Each of these variants correspond to a different category of curve equation.  Certain encoding functions may have requirements on the curve form, the characteristic of the field, and the parameters of the curve.</p>
<p id="rfc.section.2.1.p.4">An elliptic curve E is specified by an equation and a finite field F. The curve E forms a group, whose elements are points who satisfy the curve equation, and the coordinates of a point are elements of F. As a group, E has order n, which is the number of points on the curve. For security reasons, it is a strong requirement that all cryptographic operations take place in a prime order group. However, not all elliptic curves generate groups of prime order.  For example, some elliptic curves have order n = h*r, where r is a large prime, and h is a non-negative integer known as the cofactor. Thus, one may wish an encoding that returns points on a subgroup of order r. To this end, the cofactor clearing process consists on multiplying a point P on E by the cofactor h, this guarantees that hP is a point belonging to a subgroup of order r.</p>
<p id="rfc.section.2.1.p.5">Summary of quantities:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="center">Symbol</th>
<th class="left">Meaning</th>
<th class="left">Relevance</th>
</tr></thead>
<tbody>
<tr>
<td class="center">F,q,p</td>
<td class="left">Finite field F of characteristic p and #F=q=p^m.</td>
<td class="left">For prime fields, q=p; otherwise, q=p^m and m&gt;1.</td>
</tr>
<tr>
<td class="center">E</td>
<td class="left">Elliptic curve.</td>
<td class="left">E is specified by an equation and a field F.</td>
</tr>
<tr>
<td class="center">n</td>
<td class="left">Number of points on E, #E(F)=n.</td>
<td class="left">This value can be factored as n=h*r.</td>
</tr>
<tr>
<td class="center">r</td>
<td class="left">Order of a prime subgroup of E.</td>
<td class="left">If n is not prime, may need mapping to points in a subgroup of order r.</td>
</tr>
<tr>
<td class="center">h</td>
<td class="left">Cofactor, h&gt;=1.</td>
<td class="left">Constant used in cofactor clearing to map to prime-order subgroup.</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.2.p.1">In the following, we categorize the terminology for mapping bitstrings to points on elliptic curves.</p>
<h1 id="rfc.section.2.2.1">
<a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#term-encoding" id="term-encoding">Encoding</a>
</h1>
<p id="rfc.section.2.2.1.p.1">In practice, the input of a given cryptographic algorithm will be a bitstring of arbitrary length, denoted {0, 1}^*. Hence, a concern for virtually all protocols involving elliptic curves is how to convert this input into a point on the curve.  The general term &#8220;encoding&#8221; refers to the process of producing an elliptic curve point given as input a bitstring. In some protocols, the original message may also be recovered through a decoding procedure. An encoding may be deterministic or probabilistic, although the latter is a potential source of plaintext information leakage in face of side-channel attacks.</p>
<p id="rfc.section.2.2.1.p.2">Suppose that the input of the encoding function is a bitstring of fixed-length L. Comparing sizes of the sets, 2^L and n, an encoding function cannot be both deterministic and bijective. Alternatively, an injective encoding from {0, 1}^L to E can be used, such that L &lt; log2(n) - 1, which is a bijection over a subset of points on E. This ensures that encoded plaintext messages can be recovered.</p>
<p id="rfc.section.2.2.1.p.3">In practice, encodings are commonly injective and invertible. Injective encodings map inputs to a subset of points on the curve. Invertible encodings allow computation of input bitstrings given a point on the curve.</p>
<h1 id="rfc.section.2.2.2">
<a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#term-serialization" id="term-serialization">Serialization</a>
</h1>
<p id="rfc.section.2.2.2.p.1">A related task is the conversion of an elliptic curve point to a bitstring, hereafter referred as &#8220;serialization&#8221;, which is typically used for compactly storing and transporting points. For example, in <a href="#SECG1" class="xref">[SECG1]</a> there is a standard method for serializing points. Some applications have instantiated encoding algorithms using this deserialization method. However, this approach fails on bit strings that were not generated using the serialization procedure.</p>
<h1 id="rfc.section.2.2.3">
<a href="#rfc.section.2.2.3">2.2.3.</a> <a href="#term-rom" id="term-rom">Random Oracle</a>
</h1>
<p id="rfc.section.2.2.3.p.1">In practice, two types of mappings are common: (1) injective encodings, which can be used to construct a PRF as F(k, m) = k*H(m), and (2) random oracles, which used by PAKE protocols <a href="#BMP00" class="xref">[BMP00]</a>, short BLS signatures <a href="#BLS01" class="xref">[BLS01]</a>, and IBE schemes <a href="#BF01" class="xref">[BF01]</a>. When the required mapping is not clear, applications SHOULD use a random oracle.</p>
<p id="rfc.section.2.2.3.p.2">Cryptographic protocols which are proven secure in the random oracle model (ROM) often require a hash function that maps bitstrings to elements of a group and that behaves as a random oracle, i.e., its response must be uniformly distributed on the set of outputs (uniformity property).  Instantiating one of these protocols with an elliptic curve group motivates the term &#8220;hashing to the curve&#8221;, i.e., mapping bitstrings to points on an elliptic curve.</p>
<p id="rfc.section.2.2.3.p.3">The hash2curve(alpha) function can be easily constructed by using the output of a cryptographically secure hash function H as the input of an encoding function.  On the one hand, hash2curve is difficult to invert since it is computationally intractable to produce an input alpha that maps to hash2curve(alpha) due to H is pre-image resistant.  On the other hand, the uniformity property is not met as the output of an encoding is distinguishable from a random distribution. Hence, using hash2curve(alpha) is not sufficient to get uniformity, however it can be used as a building block for obtaining a random oracle as is described in <a href="#rom" class="xref">Section 6</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#utility" id="utility">Utility Functions</a>
</h1>
<p id="rfc.section.3.p.1">Algorithms in this document make use of utility functions described below.</p>
<pre>
  is_square(x, q) := { True,  if x^((q-1)/2) is 0 or 1;
                     { False, otherwise.
</pre>
<p></p>

<ul>
<li>is_square(x, q): It returns True whenever the value x is a quadratic residue in a field of order q. Due to Euler&#8217;s criterion, this function can be calculated in constant time as  <br><br> <br><br> For clarity, it is generally preferred to use this formula directly, and annotate its usage with this definition.</li>
<li>sqrt(x, q): The sqrt operation is a multi-valued function, i.e. there exist two roots of x whenever x is a quadratic residue. To maintain compatibility across implementations, a single-valued sqrt function is necessary. One way to get such a function is by distinguishing a principal square root through a predicate that only one of the roots holds.  Alternatively, an implementation of sqrt can use fixed formulas for its calculation. For instance, in prime fields, the square root of a quadratic residue x can be obtained as follows <ul>
<li>If q=3 (mod 4), sqrt(x, q) := x^((q+1)/4).</li>
<li>If q=5 (mod 8), set z := x^((q+3)/8) and verify that z^2 = -x, if so, update z = z*sqrt(-1). Finally, sqrt(x, q) := z.</li>
</ul>
<p> For extension fields, there exist methods that can be used in replacement, see </p>
<a href="#Adj13" class="xref">[Adj13]</a>, <a href="#SC85" class="xref">[SC85]</a>. Regardless the method chosen, the sqrt function MUST be performed in constant time.</li>
<li>CMOV(a, b, c): If c=0, CMOV returns a, otherwise returns b. To prevent against timing attacks, this operation must run in constant time without revealing the value of c. Commonly some implementations assume the selector be c=1 or c=0; thus, given a bitstring C, the desired selector c can be computed by OR-ing all bits of C together. The resulting selector will be either 0 if all bits of C are zero, or 1 if at least one bit of C is 1.</li>
<li>I2OSP and OS2IP: These functions are used to convert an octet string to and from a non-negative integer <a href="#RFC8017" class="xref">[RFC8017]</a>.</li>
<li>a || b: denotes the concatenation of bitstrings a and b.</li>
</ul>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#hashtobase" id="hashtobase">Hashing to a Finite Field</a>
</h1>
<p id="rfc.section.4.p.1">The hash2base(x) function maps an arbitrary-large bitstring x into an element of a field F. Hence, it is parametrized by F and H, where H is a cryptographic hash function which outputs at least floor(log2(p)) + 1 bits.</p>
<p id="rfc.section.4.p.2">When q=p, the function first hashes x, converts the result to an integer, and reduces modulo p to produce a prime field element.  When m&gt;1, q=p^m and an element of a finite field can be constructed using m prime field elements assuming that elements are in a polynomial representation.</p>
<p id="rfc.section.4.p.3">Uniformity: most algorithms assume that hash2base maps its input to the finite field uniformly. In practice, there will be inherent biases. For example, let H=SHA256 and F be a field of characteristic p = 2^255 - 19, then by reducing from a 256-bit output, the values from 2^256 - 38 to 2^256 - 1 have more probability to be chosen. In this example, the resulting bias is negligible, but for others this bias could be significant. This is a standard problem in generating uniformly distributed integers from a bitstring. In order to smooth out this bias, the hash2base algorithm should use a hash function that produces as many bits as possible before reducing modulo p. This approach is preferable to an iterated procedure, such as rejection sampling, since this can be hard to reliably implement in constant time.</p>
<p id="rfc.section.4.p.4">Performance: hash2base requires hashing the entire input x. In some algorithms or ciphersuite combinations, hash2base is called multiple times. For large inputs, implementers can therefore consider hashing x before calling hash2base, i.e., setting x=H(x).</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#implementation" id="implementation">Implementation</a>
</h1>
<p id="rfc.section.4.1.p.1">The following procedure implements hash2base.</p>
<pre>
hash2base(x)

Parameters:
  1. H, a cryptographic hash function producing k bits.
  2. F, a finite field F of characteristic p and order q=p^m.
Preconditions:  k &gt;= floor(log2(p)) + 1.
Input: x, an octet string to be hashed.
Output: y, an element in F.

Steps:
  Case q=p
    1. t1 = H(x)
    2. t2 = OS2IP(t1)
    3. y = t2 mod p
    4. Output y

  Case q=p^m and m&gt;1
    1. t = H(x)
    2. for i=0 to m-1
    3.    t1 = H( t || I2OSP(i,2) )
    4.    t2 = OS2IP(t1)
    5.    e_i = t2 mod p
    6. Output y = ( e_0, ..., e_{m-1} )
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#encodings" id="encodings">Deterministic Encodings</a>
</h1>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#interface" id="interface">Interface</a>
</h1>
<p id="rfc.section.5.1.p.1">The generic interface for deterministic encoding functions to elliptic curves is as follows:</p>
<pre>
(x, y) = map2curve(alpha)
</pre>
<p id="rfc.section.5.1.p.2">where alpha is an octet string to be hashed to a point on the curve with affine coordinates (x, y) defined over F. Observe that each encoding requires that certain algebraic conditions must hold in order to be applied.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#notation" id="notation">Notation</a>
</h1>
<p id="rfc.section.5.2.p.1">As a rough style guide the following convention is used:</p>
<p></p>

<ul>
<li>All arithmetic operations are performed over the finite field, unless otherwise be explicitly stated, e.g., integer arithmetic.</li>
<li>(x, y): are the affine coordinates of a point obtained by the encoding method.  Indexed values are used when the algorithm calculates some candidate values.</li>
<li>u: denotes an element of F produced by the hash2base function and is used as initial value of the encoding.</li>
<li>t1, t2, &#8230;: are reusable temporary variables. For notable variables, distinct names are used easing the debugging process when correlating with test vectors.</li>
<li>c1, c2, &#8230;: are constant values, which can be computed in advance.</li>
</ul>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#clearing-cofactor" id="clearing-cofactor">Clearing Cofactor</a>
</h1>
<p id="rfc.section.5.3.p.1">Encodings guarantee that the resulting point satisfies the elliptic curve equation. However, to obtain a point in a subgroup of order r, the cofactor clearing process must be performed. In the description of each encoding, the last step returns h*(x,y) which represents the cofactor clearing operation.</p>
<p id="rfc.section.5.3.p.2">For prime order groups, h=1 and then no operation is required. On the other hand, when h&gt;1, cofactor clearing is performed, in most of cases, as a scalar multiplication by h. However, on pairing-friendly curves, h is a large number when the subgroup G2 is over an extension field. In this case, cofactor clearing can be performed faster using better algorithms than scalar multiplication by h, such as the ones described in <a href="#SC09" class="xref">[SC09]</a>, <a href="#FU11" class="xref">[FU11]</a>, and <a href="#BU18" class="xref">[BU18]</a>.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#encodings-for-weierstrass-curves" id="encodings-for-weierstrass-curves">Encodings for Weierstrass curves</a>
</h1>
<p id="rfc.section.5.4.p.1">The following encodings apply to elliptic curves defined by the equation E: y^2 = x^3 + A*x + B, where 4*A^3 + 27*B^2 != 0.</p>
<h1 id="rfc.section.5.4.1">
<a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#icart" id="icart">Icart Method</a>
</h1>
<p id="rfc.section.5.4.1.p.1">The map2curve_icart(alpha) implements the Icart encoding method from <a href="#Icart09" class="xref">[Icart09]</a>.</p>
<p id="rfc.section.5.4.1.p.2">Preconditions: An elliptic curve over F, such that p&gt;3 and q=p^m=2 (mod 3), or p=2 (mod 3) and odd m.</p>
<p id="rfc.section.5.4.1.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.4.1.p.4">Constants: A and B, the parameters of the Weierstrass curve.</p>
<p id="rfc.section.5.4.1.p.5">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.4.1.p.6">Operations:</p>
<pre>
1. u = hash2base(alpha)
2. v = ((3*A - u^4) / 6*u)
3. x = (v^2 - B - (u^6 / 27))^((2*q - 1)/3) + (u^2 / 3)
4. y = u * x + v
5. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.4.1.1">
<a href="#rfc.section.5.4.1.1">5.4.1.1.</a> <a href="#implementation-1" id="implementation-1">Implementation</a>
</h1>
<p id="rfc.section.5.4.1.1.p.1">The following procedure implements Icart&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map2curve_icart(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:
1. c1 = (2*p - 1) / 3   // Integer arithmetic
2  c2 = 1/3
3. c3 = c2^3
4. c4 = 3 * A

Steps:
1.   u = hash2base(alpha)
2.  u2 = u^2            // u^2
3.  u4 = u2^2           // u^4
4.   v = c4 - u4        // 3 * A - u^4
5.  t1 = 6 * u          // 6 * u
6.  t1 = 1 / t1         // 1 / (6 * u)
7.   v = v * t1         // v = (3 * A - u^4)/(6 * u)
8.  x1 = v^2            // v^2
9.  x1 = x1 - B         // v^2 - B
10. u6 = u4 * c3        // u^4 / 27
11. u6 = u6 * u2        // u^6 / 27
12. x1 = x1 - u6        // v^2 - B - u^6/27
13. x1 = x^c1           // (v^2 - B - u^6/27)^(1/3)
14. t1 = u2 * c2        // u^2 / 3
15.  x = x + t1         // x = (v^2 - B - u^6/27)^(1/3) + (u^2 / 3)
16.  y = u * x          // u*x
17.  y = y + v          // y = u*x + v
18. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.4.2">
<a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#swu" id="swu">Shallue-Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.5.4.2.p.1">The map2curve_swu(alpha) implements the Shallue-Woestijne-Ulas (SWU) method by Ulas <a href="#SWU07" class="xref">[SWU07]</a>, which is based on Shallue and Woestijne <a href="#SW06" class="xref">[SW06]</a> method. The algorithm relies on the following equality</p>
<pre>
  (u^3 * g(x1)^2 * g(x2))^2 = g(x1) * g(x2) * g(x3)
</pre>
<p id="rfc.section.5.4.2.p.2">where g(x) := x^3+A*x+B. Thus, it computes three candidate points constructed in such a way that at least one of them lies on the curve.</p>
<p id="rfc.section.5.4.2.p.3">Preconditions: A Weierstrass curve over F such that A!=0 and B!=0.</p>
<p id="rfc.section.5.4.2.p.4">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.4.2.p.5">Constants: A and B, the parameters of the Weierstrass curve.</p>
<p id="rfc.section.5.4.2.p.6">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.4.2.p.7">Operations:</p>
<pre>
1.    u = hash2base(alpha || I2OSP(0,1))
2.   x1 = hash2base(alpha || I2OSP(1,1))
3.  gx1 = x1^3 + A*x1 + B
4.   x2 = (-B / A) * (1 + 1 / (u^4 * gx1^2 + u^2 * gx1))
5.  gx2 = x2^3 + A*x2 + B
6.   x3 = u^2 * gx1 * x2
7.  gx3 = x3^3 + A*x3 + B
8.  If gx1 is square, set x = x1 and y = sqrt(gx1)
9.  If gx2 is square, set x = x2 and y = sqrt(gx2)
10. If gx3 is square, set x = x3 and y = sqrt(gx3)
11. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.4.2.1">
<a href="#rfc.section.5.4.2.1">5.4.2.1.</a> <a href="#implementation-2" id="implementation-2">Implementation</a>
</h1>
<p id="rfc.section.5.4.2.1.p.1">The following procedure implements SWU&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map2curve_swu(alpha)

Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:
1. c1 = - B / A

Steps:
1.    u = hash2base(alpha || I2OSP(0,1))
2.   x1 = hash2base(alpha || I2OSP(1,1))
3.  gx1 = x1^2
4.  gx1 = gx1 + A
5.  gx1 = gx1 * x1
6.  gx1 = gx1 + B       // gx1 = x1^3 + A*x1 + B
7.   t1 = u^2
8.   t1 = t1 * gx1      // t1 = u^2 * gx1
9.   t2 = t1^2
10.  t2 = t2 + t1      
11.  t2 = 1 / t2        // t2 = 1 / (t1^2 + t1)
12.  x2 = t2 + 1
13.  x2 = x2 * c1       // x2 = (-B/A) * (1 + 1/(u^4*gx1^2 + u^2*gx1))
14. gx2 = x2^2
15. gx2 = gx2 + A
16. gx2 = gx2 * x2
17. gx2 = gx2 + B       // gx2 = x2^3 + A*x2 + B
18.  x3 = t1 * x2       // x3 = u^2 * gx1 * x2
19. gx3 = x3^2
20. gx3 = gx3 + A
21. gx3 = gx3 * x3
22. gx3 = gx3 + B       // gx3 = x3^3 + A*x3 + B
23.  e1 = is_square(gx1, q)
24.  e2 = is_square(gx2, q)
25.   x = CMOV(x3, x2, e2)    // If e2=True, x = x2, else x = x3
26.   x = CMOV(x, x1, e1)     // If e1=True, x = x1, else x = x
27.  gx = CMOV(gx3, gx2, e2)  // If e2=True, gx = gx2, else gx = gx3
28.  gx = CMOV(gx, gx1, e1)   // If e1=True, gx = gx1, else gx = gx
29.   y = sqrt(gx, q)
30. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.4.3">
<a href="#rfc.section.5.4.3">5.4.3.</a> <a href="#simple-swu" id="simple-swu">Simplified SWU Method</a>
</h1>
<p id="rfc.section.5.4.3.p.1">The map2curve_simple_swu(alpha) implements a simplified version of Shallue-Woestijne-Ulas algorithm given by Brier et al. <a href="#BR01" class="xref">[BR01]</a>.</p>
<p id="rfc.section.5.4.3.p.2">Preconditions: A Weierstrass curve over F such that A!=0, B!=0, and p=3 (mod 4).</p>
<p id="rfc.section.5.4.3.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.4.3.p.4">Constants: A and B, the parameters of the Weierstrass curve.</p>
<p id="rfc.section.5.4.3.p.5">Output: (x,y), a point on E.</p>
<p id="rfc.section.5.4.3.p.6">Operations:</p>
<pre>
1.   u = hash2base(alpha)
2.  x1 = (-B / A) * (1 + (1 / (u^4 - u^2)))
3. gx1 = x1^3 + A*x1 + B
4.  x2 = -u^2 * x1
5. gx2 = x2^3 + A*x2 + B
6. If gx1 is square, set x = x1 and y = sqrt(gx1)
7. If gx2 is square, set x = x2 and y = sqrt(gx2)
8. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.4.3.1">
<a href="#rfc.section.5.4.3.1">5.4.3.1.</a> <a href="#implementation-3" id="implementation-3">Implementation</a>
</h1>
<p id="rfc.section.5.4.3.1.p.1">The following procedure implements the Simple SWU&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map2curve_simple_swu(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:
1.  c1 = - B / A

Steps:
1.    u = hash2base(alpha)
2.   t1 = -u^2            
3.   t2 = t1^2            
4.   x1 = t2 + t1
5.   x1 = 1 / x1
6.   x1 = x1 + 1         
7.   x1 = x1 * c1            // x1 = (-B / A) * (1 + (1 / (u^4 - u^2)))
8.  gx1 = x1^2
9.  gx1 = gx1 + A
10. gx1 = gx1 * x1
11. gx1 = gx1 + B            // gx1 = x1^3 + A*x1 + B
12.  x2 = t1 * x1            // x2 = -u^2 * x1
13. gx2 = x2^2
14. gx2 = gx2 + A
15. gx2 = gx2 * x2
16. gx2 = gx2 + B            // gx2 = x2^3 + A*x2 + B
17.   e = is_square(gx1, q)
18.   x = CMOV(x2, x1, e)    // If e=True, x = x1, else x = x2
19.  gx = CMOV(gx2, gx1, e)  // If e=True, gx = gx1, else gx = gx2
20.   y = sqrt(gx, q)
21. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#encodings-for-montgomery-curves" id="encodings-for-montgomery-curves">Encodings for Montgomery curves</a>
</h1>
<h1 id="rfc.section.5.5.1">
<a href="#rfc.section.5.5.1">5.5.1.</a> <a href="#elligator2" id="elligator2">Elligator2 Method</a>
</h1>
<p id="rfc.section.5.5.1.p.1">The map2curve_elligator2(alpha) implements the Elligator2 <a href="#Elligator2" class="xref">[Elligator2]</a> for curves defined by y^2 = x^3 + A*x^2 + B*x such that A*B*(A^2 - 4*B) != 0.  In particular, this method applies to the Montgomery curves y^2 = x^3 + A*x^2 + x setting B=1.</p>
<p id="rfc.section.5.5.1.p.2">Preconditions: A Montgomery curve such that A!=0.</p>
<p id="rfc.section.5.5.1.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.5.1.p.4">Constants: A and B, the parameters of the curve; N, a non-square in F.</p>
<p id="rfc.section.5.5.1.p.5">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.5.1.p.6">Operations:</p>
<pre>
1.   u = hash2base(alpha)
2.  x1 = -A / (1 + N * u^2)
3. gx1 = x1^3 + A * x1^2 + B * x1
4.  x2 = -x1 - A
5. gx2 = x2^3 + A * x2^2 + B * x2
6.   e = gx1^((q - 1) / 2)
7. If is_square(gx1), set x = x1 and y = -e * sqrt(gx1)
8. If is_square(gx2), set x = x2 and y = -e * sqrt(gx2)
9. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.5.1.1">
<a href="#rfc.section.5.5.1.1">5.5.1.1.</a> <a href="#implementation-4" id="implementation-4">Implementation</a>
</h1>
<p id="rfc.section.5.5.1.1.p.1">The following procedure implements elligator2 algorithm in a straight-line fashion.</p>
<pre>
map2curve_elligator2(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:  
1. c1 is an non-square in F.
2. c2 = (q - 1) / 2      // Integer arithmetic

Steps:
1.    u = hash2base(alpha)
2.   x1 = u^2
3.   x1 = c1 * x1        
4.   x1 = x1 + 1
5.   x1 = 1 / x1
6.   x1 = A * x1
7.   x1 = -x1            // x1 = -A / (1 + N * u^2)
8.  gx1 = x1 + A
9.  gx1 = gx1 * x1
10. gx1 = gx1 + B
11. gx1 = gx1 * x1       // gx1 = x1^3 + A * x1^2 + B * x1
12.  x2 = -x1 - A        // x2 = -x1 - A
13. gx2 = x2 + A
14. gx2 = gx2 * x2
15. gx2 = gx2 + B
16. gx2 = gx2 * x2       // gx2 = x2^3 + A * x2^2 + B * x2
17.   e = is_square(gx1, q)
18.   x = CMOV(x2, x1, e)    // If e=True, x=x1, else x=x2
19.  gx = CMOV(gx2, gx1, e)  // If e=True, x=gx1, else x=gx2
20.  y2 = sqrt(gx, q)
22.  y1 = -y2
22.   y = CMOV(y2, y1, e)    // If e=True, y=y1, else y=y2
23. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#encodings-for-twisted-edwards-curves" id="encodings-for-twisted-edwards-curves">Encodings for twisted Edwards curves</a>
</h1>
<h1 id="rfc.section.5.6.1">
<a href="#rfc.section.5.6.1">5.6.1.</a> <a href="#ell2edwards" id="ell2edwards">Elligator2 Method</a>
</h1>
<p id="rfc.section.5.6.1.p.1">The map2curve_ell2edwards(alpha) implements an adaptation of Elligator2 <a href="#Elligator2" class="xref">[Elligator2]</a> for twisted Edwards curves defined by A*x^2 + y^2 = 1 + D*x^2y^2 over a field F.</p>
<p id="rfc.section.5.6.1.p.2">Preconditions: A Twisted Edwards curve.</p>
<p id="rfc.section.5.6.1.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.6.1.p.4">Constants: A and D, the parameters of the curve; N, a non-square in F.</p>
<p id="rfc.section.5.6.1.p.5">Output: (x,y), a point on E.</p>
<p id="rfc.section.5.6.1.p.6">Operations:</p>
<pre>
1.  u = hash2base(alpha)
2. c1 = 2 * (A + D) / (A - D)
3. t1 = -c1 / (1 + N * u^2)
4. t2 = -t1 - c1
5. g1 = t1^3 + c1 * t1^2 + t1
6. If is_square(g1), set t = t1, else t = t2
7. y = (t - 1) / (t + 1)
8. x = sqrt((y^2 - 1) / (D * y^2 - A), q)
9. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.6.1.1">
<a href="#rfc.section.5.6.1.1">5.6.1.1.</a> <a href="#implementation-5" id="implementation-5">Implementation</a>
</h1>
<p id="rfc.section.5.6.1.1.p.1">The following procedure implements elligator2 method in a straight-line fashion.</p>
<pre>
map2curve_ell2edwards(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:  
1. c0 is an non-square in F.
2. c1 = 2 * (A + D) / (A - D).

Steps:
1.   u = hash2base(alpha)
2.  t1 = u^2
3.  t1 = c0 * t1
4.  t1 = t1 + 1
5.  t1 = 1 / t1
6.  t1 = t1 * c1
7.  t1 = -t1                // t1 = -c1 / (1 + c0 * u^2)
8.  t2 = -t1 - c1           // t2 = -x1 - c1
9.  g1 = t1 + c1
10. g1 = g1 * t1
11. g1 = g1 + 1
12. g1 = g1 * t1            // g1 = t1^3 + c1 * t1^2 + t1
13.  e = is_square(g1, q)
14. t3 = CMOV(t2, t1, e)    // If e=True, t=t1, else t=t2
15. t4 = t3 + 1
16. t4 = 1 / t4
17.  y = t3 - 1
18.  y = y * t4
19. t5 = y^2
20. gx = t5 * D
21. gx = gx - A
22. gx = 1 / gx
23. t5 = t5 - 1
24. gx = gx * t5
25.  x = sqrt(gx, q)
26. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#encodings-for-supersingular-curves" id="encodings-for-supersingular-curves">Encodings for Supersingular curves</a>
</h1>
<h1 id="rfc.section.5.7.1">
<a href="#rfc.section.5.7.1">5.7.1.</a> <a href="#supersingular" id="supersingular">Boneh-Franklin Method</a>
</h1>
<p id="rfc.section.5.7.1.p.1">The map2curve_bf(alpha) implements the Boneh-Franklin method <a href="#BF01" class="xref">[BF01]</a> which covers the supersingular curves defined by y^2 = x^3 + B over a field F such that q=2 (mod 3).</p>
<p id="rfc.section.5.7.1.p.2">Preconditions: A supersingular curve over F such that q=2 (mod 3).</p>
<p id="rfc.section.5.7.1.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.7.1.p.4">Constants: B, the parameter of the supersingular curve.</p>
<p id="rfc.section.5.7.1.p.5">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.7.1.p.6">Operations:</p>
<pre>
1. u = hash2base(alpha)
2. x = (u^2 - B)^((2 * q - 1) / 3)
3. y = u
4. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.7.1.1">
<a href="#rfc.section.5.7.1.1">5.7.1.1.</a> <a href="#implementation-6" id="implementation-6">Implementation</a>
</h1>
<p id="rfc.section.5.7.1.1.p.1">The following procedure implements the Boneh-Franklin&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map2curve_bf(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:
1. c1 = (2 * q - 1) / 3   // Integer arithmetic

Steps:
1.  u = hash2base(alpha)
2. t1 = u^2
3. t1 = t1 - B
4.  x = t1^c1             // x = (u^2 - B)^((2 * q - 1) / 3)
5.  y = u
6. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.7.2">
<a href="#rfc.section.5.7.2">5.7.2.</a> <a href="#elligator2a0-method" id="elligator2a0-method">Elligator2A0 Method</a>
</h1>
<p id="rfc.section.5.7.2.p.1">The map2curve_ell2A0(alpha) implements an adaptation of Elligator2 <a href="#Elligator2A0" class="xref">[Elligator2A0]</a> targeting the supersingular curves defined by y^2 = x^3 + B*x over a field F such that q=3 (mod 4).</p>
<p id="rfc.section.5.7.2.p.2">Preconditions: A supersingular curve over F such that q=3 (mod 4).</p>
<p id="rfc.section.5.7.2.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.7.2.p.4">Constants: B, the parameter of the supersingular curve.</p>
<p id="rfc.section.5.7.2.p.5">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.7.2.p.6">Operations:</p>
<pre>
1.   u = hash2base(alpha)
2.  x1 = u
3. gx1 = x1^3 + B * x1
2.  x2 = -x1
3. gx2 = x2^3 + B * x2
8. If gx1 is square, x = x1 and y = sqrt(gx1)
9. If gx2 is square, x = x2 and y = sqrt(gx2)
10. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.7.2.1">
<a href="#rfc.section.5.7.2.1">5.7.2.1.</a> <a href="#implementation-7" id="implementation-7">Implementation</a>
</h1>
<p id="rfc.section.5.7.2.1.p.1">The following procedure implements the Elligator2&#8217;s algorithm for supersingular curves in a straight-line fashion.</p>
<pre>
map2curve_ell2A0(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Steps:
1.   u = hash2base(alpha)
2.  x1 = u
3. gx1 = x1^2
4. gx1 = gx1 + B
5. gx1 = gx1 * x1     // gx1 = x1^3 + B * x1
6.  x2 = -x1
7. gx2 = -gx1         // gx2 = x2^3 + B * x2
8.   e = is_square(gx1, q)
9.   x = CMOV(x2, x1, e)    // If e=True, x = x1, else x = x2
10. gx = CMOV(gx2, gx1, e)  // If e=True, gx = gx1, else gx = gx2
11.  y = sqrt(gx, q)
12. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> <a href="#encodings-for-pairing-friendly-curves" id="encodings-for-pairing-friendly-curves">Encodings for Pairing-Friendly curves</a>
</h1>
<h1 id="rfc.section.5.8.1">
<a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#ftpairing" id="ftpairing">Fouque-Tibouchi Method</a>
</h1>
<p id="rfc.section.5.8.1.p.1">The map2curve_ft(alpha) implements the Fouque-Tibouchi&#8217;s method <a href="#FT12" class="xref">[FT12]</a> for elliptic curves defined by y^2 = x^3 + B. Notice that this encoding covers the case q=1 (mod 3) which is not handled by Boneh-Franklin&#8217;s method, e.g., the SECP256K1 curve <a href="#SEC2" class="xref">[SEC2]</a>. In addition, this encoding covers pairing-friendly curves, such as BN <a href="#BN05" class="xref">[BN05]</a>, KSS <a href="#KSS08" class="xref">[KSS08]</a>, and BLS <a href="#BLS02" class="xref">[BLS02]</a> curves.</p>
<p id="rfc.section.5.8.1.p.2">Preconditions: A Weierstrass curve over F such that q=7 (mod 12).</p>
<p id="rfc.section.5.8.1.p.3">Input: alpha, an octet string to be hashed.</p>
<p id="rfc.section.5.8.1.p.4">Constants: B, the constant of the Weierstrass curve; and S=sqrt(-3) in F.</p>
<p id="rfc.section.5.8.1.p.5">Output: (x, y), a point on E.</p>
<p id="rfc.section.5.8.1.p.6">Operations:</p>
<pre>
1.  u = hash2base(alpha)
2. t1 = (S * u) / (1 + B + u^2)
3. x1 = ((-1 + S) / 2) - u * t1
4. x2 = -1 - x1
5. x3 = 1 + (1 / t1^2)
6.  e = u^((p-1) / 2)
7. If x1^3 + B is square, set x = x1 and y = e * sqrt(x1^3 + B)
8. If x2^3 + B is square, set x = x2 and y = e * sqrt(x2^3 + B)
8. If x3^3 + B is square, set x = x3 and y = e * sqrt(x3^3 + B)
9. Output h*(x, y)
</pre>
<h1 id="rfc.section.5.8.1.1">
<a href="#rfc.section.5.8.1.1">5.8.1.1.</a> <a href="#implementation-8" id="implementation-8">Implementation</a>
</h1>
<p id="rfc.section.5.8.1.1.p.1">The following procedure implements the Fouque-Tibouchi&#8217;s algorithm in a straight-line fashion.</p>
<pre>
map2curve_ft(alpha)
Input: alpha, an octet string to be hashed.
Output: (x, y), a point on E.

Constants:
1. c1 = sqrt(-3)          
2. c2 = (-1 + c1) / 2     
3. c3 = ((q-1) / 2)    // Integer Arithmetic

Steps:
1.    u = hash2base(alpha)
2.   t1 = u^2
3.   t1 = t1 + B + 1
4.   t1 = 1 / t1
5.   t1 = t1 * u
6.   t1 = t1 * c1      // t1 = sqrt(-3) * u / (u^2 + B + 1)
7.   x1 = u * t1
8.   x1 = c2 - x1      // x1 = (-1 + sqrt(-3)) / 2 - sqrt(-3) * u / (u^2 + B + 1)
9.   x2 = -1 - x1      // x2 = -1 - x1
10.  x3 = t1^2
11.  x3 = 1 / x3
12.  x3 = x3 + 1       // x3 = 1 + (1 / t1^2)
13. gx1 = x1^3 + B
14. gx2 = x2^3 + B
15. gx3 = x3^3 + B
16.  e1 = is_square(gx1, q)
17.  e2 = is_square(gx2, q)
18.   x = CMOV(x3, x2, e2)    // If e2=True, x = x2, else x = x3
19.   x = CMOV(x, x1, e1)     // If e1=True, x = x1, else x = x
20.  gx = CMOV(gx3, gx2, e2)  // If e2=True, gx = gx2, else gx = gx3
21.  gx = CMOV(gx, gx1, e1)   // If e1=True, gx = gx1, else gx = gx
22.   e = u^c3
23.   y = e * sqrt(gx, q)
24. Output h*(x, y)
</pre>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#rom" id="rom">Random Oracles</a>
</h1>
<p id="rfc.section.6.p.1">A random oracle onto an elliptic curve can be instantiated using some general constructions. For example, Brier et al. <a href="#BR01" class="xref">[BR01]</a> proved a construction that requires a scalar point multiplication, however this approach turns hashing into an expensive operation.  A more efficient method to get a random oracle was given by Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> and is defined as follows</p>
<pre>
   hash2curveRO(alpha) = f(H0(alpha)) + f(H1(alpha))
</pre>
<p id="rfc.section.6.p.2">where f: F -&gt; E is a deterministic encoding function; and H0 and H1 are hash functions modeled as random oracles mapping bitstrings to elements in a field F.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#interface-1" id="interface-1">Interface</a>
</h1>
<p id="rfc.section.6.1.p.1">Using the deterministic encodings from <a href="#encodings" class="xref">Section 5</a>, the random oracle recommended is instantiated as</p>
<pre>
 hash2curveRO(alpha) = map2curve( alpha || I2OSP(0x02, 1) )
                     + map2curve( alpha || I2OSP(0x03, 1) )
</pre>
<p id="rfc.section.6.1.p.2">where the addition operation is performed as a point addition on the curve.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#suites" id="suites">Suites for Hashing</a>
</h1>
<p id="rfc.section.7.p.1">The following table lists recommended algorithms for different curves and mappings. To select a suitable algorithm, choose the mapping associated with the target curve. For example, Elligator2 is the recommended encoding for Curve25519, whereas Simple SWU is the recommended encoding for P-256.  When the required hashing requires to be used in a protocol proven in the random oracle model, applications SHOULD use the Random Oracle construction given in <a href="#rom" class="xref">Section 6</a>.</p>
<p id="rfc.section.7.p.2">A suite is a bundle of algorithms that provides concrete recommendations for hashing bitstrings into points of specific elliptic curve groups. Each suite is a tuple (E, H, f, ROM) such that</p>
<p></p>

<ul>
<li>E, is the elliptic curve group.</li>
<li>H, is the cryptographic hash function used by hash2base.</li>
<li>f, is an encoding function compatible with E.</li>
<li>ROM, is a boolean flag indicating whether or not to use the random oracle construction.</li>
</ul>
<p id="rfc.section.7.p.4">This document describes the following set of ciphersuites</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">Suite ID</th>
<th class="left">E</th>
<th class="left">H</th>
<th class="left">f</th>
<th class="left">ROM</th>
</tr></thead>
<tbody>
<tr>
<td class="left">H2C-0001</td>
<td class="left">P256</td>
<td class="left">SHA256</td>
<td class="left">Simple SWU</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0002</td>
<td class="left">P384</td>
<td class="left">SHA512</td>
<td class="left">Icart</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0003</td>
<td class="left">curve25519</td>
<td class="left">SHA512</td>
<td class="left">Elligator2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0004</td>
<td class="left">curve448</td>
<td class="left">SHA512</td>
<td class="left">Elligator2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0005</td>
<td class="left">edwards25519</td>
<td class="left">SHA512</td>
<td class="left">Elligator2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0006</td>
<td class="left">edwards448</td>
<td class="left">SHA512</td>
<td class="left">Elligator2</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0007</td>
<td class="left">SECP256K1</td>
<td class="left">SHA512</td>
<td class="left">FT</td>
<td class="left">True</td>
</tr>
<tr>
<td class="left">H2C-0008</td>
<td class="left">BLS12381</td>
<td class="left">SHA512</td>
<td class="left">FT</td>
<td class="left">True</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document has no IANA actions.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.9.p.1">Each encoding function variant accepts arbitrary input and maps it to a pseudorandom point on the curve. Points are close to indistinguishable from randomly chosen elements on the curve. Not all encoding functions are full-domain hashes. Elligator2, for example, only maps strings to &#8220;about half of all curve points,&#8221; whereas Icart&#8217;s method only covers about 5/8 of the points.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.10.p.1">The authors would like to thank Adam Langley for this detailed writeup up Elligator2 with Curve25519 <a href="#ElligatorAGL" class="xref">[ElligatorAGL]</a>. We also thank Sean Devlin and Thomas Icart for feedback on earlier versions of this document.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#contributors" id="contributors">Contributors</a>
</h1>
<p></p>

<ul>
<li>Sharon Goldberg <br> Boston University <br> goldbe@cs.bu.edu</li>
<li>Ela Lee <br> Royal Holloway, University of London <br> Ela.Lee.2010@live.rhul.ac.uk</li>
</ul>
<h1 id="rfc.references">
<a href="#rfc.references">12.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="Adj13">[Adj13]</b></td>
<td class="top">
<a title="ISFA, Universite Claude Bernard Lyon 1, Villeurbanne, France">Adj, G.</a> and <a title="CINVESTAV-IPN, San Pedro Zacatenco, Mexico City, Mexico.">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1109/TC.2013.145">Square Root Computation over Even Extension Fields</a>", In IEEE Transactions on Computers. vol 63 issue 11, pages 2829-2841, DOI 10.1109/TC.2013.145, November 2014.</td>
</tr>
<tr>
<td class="reference"><b id="BF01">[BF01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a> and <a title="UC Davis">M. Franklin</a>, "<a href="https://doi.org/10.1007/3-540-44647-8_13">Identity-based encryption from the Weil pairing</a>", In Advances in Cryptology - CRYPTO 2001, pages 213-229, DOI 10.1007/3-540-44647-8_13, August 2001.</td>
</tr>
<tr>
<td class="reference"><b id="BLS01">[BLS01]</b></td>
<td class="top">
<a title="Stanford University">Boneh, D.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Stanford University">H. Shacham</a>, "<a href="https://doi.org/10.1007/s00145-004-0314-9">Short signatures from the Weil pairing</a>", In Journal of Cryptology, vol 17, pages 297-319, DOI 10.1007/s00145-004-0314-9, July 2004.</td>
</tr>
<tr>
<td class="reference"><b id="BLS02">[BLS02]</b></td>
<td class="top">
<a title="Universidade de Sao Paulo, Brazil">Barreto, P.</a>, <a title="Stanford University">Lynn, B.</a> and <a title="Dublin City University, Ireland">M. Scott</a>, "<a href="https://doi.org/10.1007/3-540-36413-7_19">Constructing Elliptic Curves with Prescribed Embedding Degrees</a>", In Security in Communication Networks, pages 257-267, DOI 10.1007/3-540-36413-7_19, 2003.</td>
</tr>
<tr>
<td class="reference"><b id="BMP00">[BMP00]</b></td>
<td class="top">
<a title="MIT Laboratory for Computer Science">Boyko, V.</a>, <a title="Bell Laboratories, Lucent Technologies">MacKenzie, P.</a> and <a title="Bell Laboratories, Lucent Technologies">S. Patel</a>, "<a href="https://doi.org/10.1007/3-540-45539-6_12">Provably secure password-authenticated key exchange using Diffie-Hellman</a>", In Advances in Cryptology - EUROCRYPT 2000, pages 156-171, DOI 10.1007/3-540-45539-6_12, May 2000.</td>
</tr>
<tr>
<td class="reference"><b id="BN05">[BN05]</b></td>
<td class="top">
<a title="Escola Politecnica, Universidade de Sao Paulo, Sao Paulo, Brazil">Barreto, P.</a> and <a title="Lehrstuhl fur Theoretische Informationstechnik, Rheinisch-Westfalische Technische Hochschule Aachen, Aachen, Germany">M. Naehrig</a>, "<a href="https://doi.org/10.1007/11693383_22">Pairing-Friendly Elliptic Curves of Prime Order</a>", In Selected Areas in Cryptography 2005, pages 319-331, DOI 10.1007/11693383_22, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="BR01">[BR01]</b></td>
<td class="top">
<a title="Ingenico">Brier, E.</a>, <a title="Universite du Luxembourg">Coron, J.</a>, <a title="Universite du Luxembourg">Icart, T.</a>, <a title="TELECOM-ParisTech">Madore, D.</a>, <a title="TELECOM-ParisTech">Randriam, H.</a> and <a title="Universite du Luxembourg, Ecole normale superieure">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-14623-7_13">Efficient Indifferentiable Hashing into Ordinary Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2010, pages 237-254, DOI 10.1007/978-3-642-14623-7_13, 2010.</td>
</tr>
<tr>
<td class="reference"><b id="BU18">[BU18]</b></td>
<td class="top">
<a title="University of Bergen, Norway and MIRACL Labs, London, England">Budroni, A.</a> and <a title="University of Trento, Italy">F. Pintore</a>, "<a href="https://doi.org/10.1145/3313880.3313884">Hashing to G2 on BLS pairing-friendly curves</a>", In ACM Communications in Computer Algebra, pages 63-66, DOI 10.1145/3313880.3313884, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="Elligator2">[Elligator2]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Cryptography Research, a division of Rambus, USA">Hamburg, M.</a>, <a title="Privacy &amp; Identity lab, Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands">Krasnova, A.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">T. Lange</a>, "<a href="https://doi.org/10.1145/2508859.2516734">Elligator - elliptic-curve points indistinguishable from uniform random strings</a>", In Proceedings of the 2013 ACM SIGSAC conference on computer and communications security., pages 967-980, DOI 10.1145/2508859.2516734, November 2013.</td>
</tr>
<tr>
<td class="reference"><b id="Elligator2A0">[Elligator2A0]</b></td>
<td class="top">
<a title="Department of Computer Science, University of Illinois at Chicago, USA">Bernstein, D.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Lange, T.</a>, <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">Martindale, C.</a> and <a title="Department of Mathematics and Computer Science, Technische Universiteit Eindhoven, The Netherlands">L. Panny</a>, "<a href="https://doi.org/10.1007/978-3-030-17656-3">Quantum circuits for the CSIDH optimizing quantum evaluation of isogenies</a>", In Advances in Cryptology - EUROCRYPT 2019, DOI 10.1007/978-3-030-17656-3, 2019.</td>
</tr>
<tr>
<td class="reference"><b id="ElligatorAGL">[ElligatorAGL]</b></td>
<td class="top">
<a>Langley, A.</a>, "<a href="https://www.imperialviolet.org/2013/12/25/elligator.html">Implementing Elligator for Curve25519</a>", 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FFSTV13">[FFSTV13]</b></td>
<td class="top">
<a title="Macquarie Universit">Farashahi, R.</a>, <a title="Ecole normale superieure">Fouque, P.</a>, <a title="Macquarie Universit">Shparlinski, I.</a>, <a title="Ecole normale superieure">Tibouch, M.</a> and <a title="University of Texas">J. Voloch</a>, "<a href="https://doi.org/10.1090/S0025-5718-2012-02606-8">Indifferentiable deterministic hashing to elliptic and hyperelliptic curves</a>", In Math. Comp. vol 82, pages 491-512, DOI 10.1090/S0025-5718-2012-02606-8, 2013.</td>
</tr>
<tr>
<td class="reference"><b id="FT12">[FT12]</b></td>
<td class="top">
<a title="Ecole Normale Superieure and INRIA Rennes">Fouque, P.</a> and <a title="NTT Secure Platform Laboratories">M. Tibouchi</a>, "<a href="https://doi.org/10.1007/978-3-642-33481-8_1">Indifferentiable Hashing to Barreto-Naehrig Curves</a>", In Progress in Cryptology - LATINCRYPT 2012, pages 1-7, DOI 10.1007/978-3-642-33481-8_1, 2012.</td>
</tr>
<tr>
<td class="reference"><b id="FU11">[FU11]</b></td>
<td class="top">
<a title="Computer Science Department, CINVESTAV-IPN. Mexico">Fuentes-Castaneda, L.</a>, <a title="Dept. Combinatorics &amp; Optimization, University of Waterloo, Canada">Knapp, E.</a> and <a title="Computer Science Department, CINVESTAV-IPN. Mexico">F. Rodriguez-Henriquez</a>, "<a href="https://doi.org/10.1007/978-3-642-28496-0_25">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Selected Areas in Cryptography, pages 412-430, DOI 10.1007/978-3-642-28496-0_25, 2011.</td>
</tr>
<tr>
<td class="reference"><b id="github-repo">[github-repo]</b></td>
<td class="top">"<a href="https://github.com/chris-wood/draft-irtf-cfrg-hash-to-curve">draft-irtf-cfrg-hash-to-curve | github.com</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="hacspec">[hacspec]</b></td>
<td class="top">"<a href="https://github.com/HACS-workshop/hacspec">hacspec</a>", January 2019.</td>
</tr>
<tr>
<td class="reference"><b id="Icart09">[Icart09]</b></td>
<td class="top">
<a title="Sagem Securite and Universite du Luxembourg">Icart, T.</a>, "<a href="https://doi.org/10.1007/978-3-642-03356-8_18">How to Hash into Elliptic Curves</a>", In Advances in Cryptology - CRYPTO 2009, pages 303-316, DOI 10.1007/978-3-642-03356-8_18, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="Jablon96">[Jablon96]</b></td>
<td class="top">
<a title="Integrity Sciences, Inc. Westboro, MA.">Jablon, D.</a>, "<a href="https://doi.org/10.1145/242896.242897">Strong password-only authenticated key exchange</a>", In SIGCOMM Computer Communication Review, vol 26 issue 5, pages 5-26, DOI 10.1145/242896.242897, 1996.</td>
</tr>
<tr>
<td class="reference"><b id="KSS08">[KSS08]</b></td>
<td class="top">
<a title="School of Computing, Dublin City University, Ireland">Kachisa, E.</a>, <a title="Department of Mathematics and Computer Science of Santa Clara University, USA">Schaefer, E.</a> and <a title="School of Computing, Dublin City University, Ireland">M. Scott</a>, "<a href="https://doi.org/10.1007/978-3-540-85538-5_9">Constructing Brezing-Weng Pairing-Friendly Elliptic Curves Using Elements in the Cyclotomic Field</a>", In Pairing-Based Cryptography - Pairing 2008, pages 126-135, DOI 10.1007/978-3-540-85538-5_9, 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8017">[RFC8017]</b></td>
<td class="top">
<a>Moriarty, K.</a>, <a>Kaliski, B.</a>, <a>Jonsson, J.</a> and <a>A. Rusch</a>, "<a href="https://tools.ietf.org/html/rfc8017">PKCS #1: RSA Cryptography Specifications Version 2.2</a>", RFC 8017, DOI 10.17487/RFC8017, November 2016.</td>
</tr>
<tr>
<td class="reference"><b id="SAGE">[SAGE]</b></td>
<td class="top">
<a>The Sage Developers</a>, "<a href="https://www.sagemath.org">SageMath, the Sage Mathematics Software System</a>", 2019.</td>
</tr>
<tr>
<td class="reference"><b id="SC09">[SC09]</b></td>
<td class="top">
<a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Scott, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Benger, N.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Charlemagne, M.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Dominguez Perez, L.</a>, <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">Benger, N.</a> and <a title="School of Computing Dublin City University, Ballymun. Dublin, Ireland.">E. Kachisa</a>, "<a href="https://doi.org/10.1007/978-3-642-03298-1_8">Fast Hashing to G2 on Pairing-Friendly Curves</a>", In Pairing-Based Cryptography - Pairing 2009, pages 102-113, DOI 10.1007/978-3-642-03298-1_8, 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SC85">[SC85]</b></td>
<td class="top">
<a>Schoof, R.</a>, "<a href="https://doi.org/10.1090/S0025-5718-1985-0777280-6">Elliptic Curves Over Finite Fields and the Computation of Square Roots mod p</a>", In Mathematics of Computation vol 44 issue 170, pages 483-494, DOI 10.1090/S0025-5718-1985-0777280-6, April 1985.</td>
</tr>
<tr>
<td class="reference"><b id="SEC2">[SEC2]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec2-v2.pdf">SEC 2: Recommended Elliptic Curve Domain Parameters</a>", January 2010.</td>
</tr>
<tr>
<td class="reference"><b id="SECG1">[SECG1]</b></td>
<td class="top">
<a>Standards for Efficient Cryptography Group (SECG)</a>, "<a href="http://www.secg.org/sec1-v2.pdf">SEC 1: Elliptic Curve Cryptography</a>", May 2009.</td>
</tr>
<tr>
<td class="reference"><b id="SW06">[SW06]</b></td>
<td class="top">
<a title="Mathematics Department, University of Wisconsin-Madison. Madison, USA.">Shallue, A.</a> and <a title="Mathematisch Instituut, Universiteit Leiden. Leiden, The Netherlands.">C. Woestijne</a>, "<a href="https://doi.org/10.1007/11792086_36">Construction of rational points on elliptic curves over finite fields</a>", In Algorithmic Number Theory. ANTS 2006., pages 510-524, DOI 10.1007/11792086_36, 2006.</td>
</tr>
<tr>
<td class="reference"><b id="SWU07">[SWU07]</b></td>
<td class="top">
<a title="Institute of Mathematics, Jagiellonian University. Poland">Ulas, M.</a>, "<a href="https://doi.org/10.4064/ba55-2-1">Rational points on certain hyperelliptic curves over finite fields</a>", In Bulletin Polish Acad. Sci. Math. vol 55, pages 97-104, DOI 10.4064/ba55-2-1, 2007.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#related" id="related">Related Work</a>
</h1>
<p id="rfc.section.A.p.1">In this chapter, we  give a background to some common methods to encode or hash to the curve, motivated by the similar exposition in <a href="#Icart09" class="xref">[Icart09]</a>.  Understanding of this material is not required in order to choose a suitable encoding function - we defer this to <a href="#suites" class="xref">Section 7</a> - the background covered here can work as a template for analyzing encoding functions not found in this document, and as a guide for further research into the topics covered.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#probabilistic-encoding" id="probabilistic-encoding">Probabilistic Encoding</a>
</h1>
<p id="rfc.section.A.1.p.1">As mentioned in <a href="#background" class="xref">Section 2</a>, as a rule of thumb, for every x in GF(p), there is approximately a 1/2 chance that there exist a corresponding y value such that (x, y) is on the curve E.</p>
<p id="rfc.section.A.1.p.2">This motivates the construction of the MapToGroup method described by Boneh et al. <a href="#BLS01" class="xref">[BLS01]</a>. For an input message m, a counter i, and a standard hash function H : {0, 1}^* -&gt; GF(p) x {0, 1}, one computes (x, b) = H(i || m), where i || m denotes concatenation of the two values. Next, test to see whether there exists a corresponding y value such that (x, y) is on the curve, returning (x, y) if successful, where b determines whether to take +/- y.  If there does not exist such a y, then increment i and repeat. A maximum counter value is set to I, and since each iteration succeeds with probability approximately 1/2, this process fails with probability 2^-I. (See <a href="#try" class="xref">Appendix B</a> for a more detailed description of this algorithm.)</p>
<p id="rfc.section.A.1.p.3">Although MapToGroup describes a method to hash to the curve, it can also be adapted to a simple encoding mechanism. For a bitstring of length strictly less than log2(p), one can make use of the spare bits in order to encode the counter value. Allocating more space for the counter increases the expansion, but reduces the failure probability.</p>
<p id="rfc.section.A.1.p.4">Since the running time of the MapToGroup algorithm depends on m, this algorithm is NOT safe for cases sensitive to timing side channel attacks.  Deterministic algorithms are needed in such cases where failures are undesirable.</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#naive-encoding" id="naive-encoding">Naive Encoding</a>
</h1>
<p id="rfc.section.A.2.p.1">A naive solution includes computing H(m)*G as map2curve(m), where H is a standard hash function H : {0, 1}^* -&gt; GF(p), and G is a generator of the curve. Although efficient, this solution is unsuitable for constructing a random oracle onto E, since the discrete logarithm with respect to G is known. For example, given y1 = map2curve(m1) and y2 = map2curve(m2) for any m1 and m2, it must be true that y2 = H(m2) / H(m1) * map2curve(m1). This relationship would not hold (with overwhelming probability) for truly random values y1 and y2.  This causes catastrophic failure in many cases. However, one exception is found in SPEKE <a href="#Jablon96" class="xref">[Jablon96]</a>, which constructs a base for a Diffie-Hellman key exchange by hashing the password to a curve point. Notably the use of a hash function is purely for encoding an arbitrary length string to a curve point, and does not need to be a random oracle.</p>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> <a href="#deterministic-encoding" id="deterministic-encoding">Deterministic Encoding</a>
</h1>
<p id="rfc.section.A.3.p.1">Shallue, Woestijne, and Ulas <a href="#SW06" class="xref">[SW06]</a> first introduced a deterministic algorithm that maps elements in F_{q} to a curve in time O(log^4 q), where q = p^n for some prime p, and time O(log^3 q) when q = 3 mod 4. Icart introduced yet another deterministic algorithm which maps F_{q} to any EC where q = 2 mod 3 in time O(log^3 q) <a href="#Icart09" class="xref">[Icart09]</a>.  Elligator (2) <a href="#Elligator2" class="xref">[Elligator2]</a> is yet another deterministic algorithm for any odd-characteristic EC that has a point of order 2. Elligator2 can be applied to Curve25519 and Curve448, which are both CFRG-recommended curves <a href="#RFC7748" class="xref">[RFC7748]</a>.</p>
<p id="rfc.section.A.3.p.2">However, an important caveat to all of the above deterministic encoding functions, is that none of them map injectively to the entire curve, but rather some fraction of the points. This makes them unable to use to directly construct a random oracle on the curve.</p>
<p id="rfc.section.A.3.p.3">Brier et al. <a href="#BR01" class="xref">[BR01]</a> proposed a couple of solutions to this problem, The first applies solely to Icart&#8217;s method described above, by computing F(H0(m)) + F(H1(m)) for two distinct hash functions H0, H1. The second uses a generator G, and computes F(H0(m)) + H1(m)*G. Later, Farashahi et al. <a href="#FFSTV13" class="xref">[FFSTV13]</a> showed the generality of the F(H0(m)) + F(H1(m)) method, as well as the applicability to hyperelliptic curves (not covered here).</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#try" id="try">Try-and-Increment Method</a>
</h1>
<p id="rfc.section.B.p.1">In cases where constant time execution is not required, the so-called try-and-increment method may be appropriate. As discussion in <a href="#introduction" class="xref">Section 1</a>, this variant works by hashing input m using a standard hash function (&#8220;Hash&#8221;), e.g., SHA256, and then checking to see if the resulting point (m, f(m)), for curve function f, belongs on E.  This is detailed below.</p>
<pre>
1. ctr = 0
2. h = "INVALID"
3. While h is "INVALID" or h is EC point at infinity:
4.1   CTR = I2OSP(ctr, 4)
4.2   ctr = ctr + 1
4.3   attempted_hash = Hash(m || CTR)
4.4   h = RS2ECP(attempted_hash)
4.5   If h is not "INVALID" and cofactor &gt; 1, set h = h * cofactor
5. Output h
</pre>
<p id="rfc.section.B.p.2">I2OSP is a function that converts a nonnegative integer to octet string as defined in Section 4.1 of <a href="#RFC8017" class="xref">[RFC8017]</a>, and RS2ECP(h) = OS2ECP(0x02 || h), where OS2ECP is specified in Section 2.3.4 of <a href="#SECG1" class="xref">[SECG1]</a>, which converts an input string into an EC point.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#samplecode" id="samplecode">Sample Code</a>
</h1>
<p id="rfc.section.C.p.1">This section contains reference implementations for each map2curve variant built using <a href="#hacspec" class="xref">[hacspec]</a>.  The code presented here corresponds to the example Sage <a href="#SAGE" class="xref">[SAGE]</a> code found at <a href="#github-repo" class="xref">[github-repo]</a>. Which is additionally used to generate intermediate test vectors.</p>
<h1 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#icart-method" id="icart-method">Icart Method</a>
</h1>
<p id="rfc.section.C.1.p.1">The following hacspec program implements map2curve_icart(alpha) for P-384.</p>
<pre>
from hacspec.speclib import *

prime = 2**384 - 2**128 - 2**96 + 2**32 - 1

felem_t = refine(nat, lambda x: x &lt; prime)
affine_t = tuple2(felem_t, felem_t)

@typechecked
def to_felem(x: nat_t) -&gt; felem_t:
    return felem_t(nat(x % prime))


@typechecked
def fadd(x: felem_t, y: felem_t) -&gt; felem_t:
    return to_felem(x + y)


@typechecked
def fsub(x: felem_t, y: felem_t) -&gt; felem_t:
    return to_felem(x - y)


@typechecked
def fmul(x: felem_t, y: felem_t) -&gt; felem_t:
    return to_felem(x * y)


@typechecked
def fsqr(x: felem_t) -&gt; felem_t:
    return to_felem(x * x)


@typechecked
def fexp(x: felem_t, n: nat_t) -&gt; felem_t:
    return to_felem(pow(x, n, prime))


@typechecked
def finv(x: felem_t) -&gt; felem_t:
    return to_felem(pow(x, prime-2, prime))

a384 = to_felem(prime - 3)
b384 = to_felem(27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575)

@typechecked
def map2p384(u:felem_t) -&gt; affine_t:
    v = fmul(fsub(fmul(to_felem(3), a384), fexp(u, 4)), finv(fmul(to_felem(6), u)))
    u2 = fmul(fexp(u, 6), finv(to_felem(27)))
    x = fsub(fsqr(v), b384)
    x = fsub(x, u2)
    x = fexp(x, (2 * prime - 1) // 3)
    x = fadd(x, fmul(fsqr(u), finv(to_felem(3))))
    y = fadd(fmul(u, x), v)
    return (x, y)
</pre>
<h1 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#shallue-woestijne-ulas-method" id="shallue-woestijne-ulas-method">Shallue-Woestijne-Ulas Method</a>
</h1>
<p id="rfc.section.C.2.p.1">The following hacspec program implements map2curve_swu(alpha) for P-256.</p>
<pre>
from p256 import *
from hacspec.speclib import *

a256 = to_felem(prime - 3)
b256 = to_felem(41058363725152142129326129780047268409114441015993725554835256314039467401291)

@typechecked
def f_p256(x:felem_t) -&gt; felem_t:
    return fadd(fexp(x, 3), fadd(fmul(to_felem(a256), x), to_felem(b256)))

@typechecked
def x1(t:felem_t, u:felem_t) -&gt; felem_t:
    return u

@typechecked
def x2(t:felem_t, u:felem_t) -&gt; felem_t:
    coefficient = fmul(to_felem(-b256), finv(to_felem(a256)))
    t2 = fsqr(t)
    t4 = fsqr(t2)
    gu = f_p256(u)
    gu2 = fsqr(gu)
    denom = fadd(fmul(t4, gu2), fmul(t2, gu))
    return fmul(coefficient, fadd(to_felem(1), finv(denom)))

@typechecked
def x3(t:felem_t, u:felem_t) -&gt; felem_t:
    return fmul(fsqr(t), fmul(f_p256(u), x2(t, u)))

@typechecked
def map2p256(t:felem_t) -&gt; felem_t:
    u = fadd(t, to_felem(1))
    x1v = x1(t, u)
    x2v = x2(t, u)
    x3v = x3(t, u)

    exp = to_felem((prime - 1) // 2)
    e1 = fexp(f_p256(x1v), exp)
    e2 = fexp(f_p256(x2v), exp)

    if e1 == 1:
        return x1v
    elif e2 == 1:
        return x2v
    else:
        return x3v
</pre>
<h1 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#sswu" id="sswu">Simplified SWU Method</a>
</h1>
<p id="rfc.section.C.3.p.1">The following hacspec program implements map2curve_simple_swu(alpha) for P-256.</p>
<pre>
from p256 import *
from hacspec.speclib import *

a256 = to_felem(prime - 3)
b256 = to_felem(41058363725152142129326129780047268409114441015993725554835256314039467401291)

def f_p256(x:felem_t) -&gt; felem_t:
    return fadd(fexp(x, 3), fadd(fmul(to_felem(a256), x), to_felem(b256)))

def map2p256(t:felem_t) -&gt; affine_t:
    alpha = to_felem(-(fsqr(t)))
    frac = finv((fadd(fsqr(alpha), alpha)))
    coefficient = fmul(to_felem(-b256), finv(to_felem(a256)))
    x2 = fmul(coefficient, fadd(to_felem(1), frac))

    x3 = fmul(alpha, x2)
    h2 = fadd(fexp(x2, 3), fadd(fmul(a256, x2), b256))
    h3 = fadd(fexp(x3, 3), fadd(fmul(a256, x3), b256))

    exp = fmul(fadd(to_felem(prime), to_felem(-1)), finv(to_felem(2)))
    e = fexp(h2, exp)

    exp = to_felem((prime + 1) // 4)
    if e == 1:
      return (x2, fexp(f_p256(x2), exp))
    else:
      return (x3, fexp(f_p256(x3), exp))
</pre>
<h1 id="rfc.appendix.C.4">
<a href="#rfc.appendix.C.4">C.4.</a> <a href="#boneh-franklin-method" id="boneh-franklin-method">Boneh-Franklin Method</a>
</h1>
<p id="rfc.section.C.4.p.1">The following hacspec program implements map2curve_bf(alpha) for a supersingular curve <samp>y^2=x^3+1</samp> over <samp>GF(p)</samp> and <samp>p = (2^250)(3^159)-1</samp>.</p>
<pre>
from hacspec.speclib import *

prime = 2**250*3**159-1

a503 = to_felem(0)
b503 = to_felem(1)

@typechecked
def map2p503(u:felem_t) -&gt; affine_t:
    t0 = fsqr(u)
    t1 = fsub(t0,b503)
    x = fexp(t1, (2 * prime - 1) // 3)
    return (x, u)
</pre>
<h1 id="rfc.appendix.C.5">
<a href="#rfc.appendix.C.5">C.5.</a> <a href="#fouque-tibouchi-method" id="fouque-tibouchi-method">Fouque-Tibouchi Method</a>
</h1>
<p id="rfc.section.C.5.p.1">The following hacspec program implements map2curve_ft(alpha) for a BN curve <samp>BN256 : y^2=x^3+1</samp> over <samp>GF(p(t))</samp>, where <samp>p(x) = 36x^4 + 36x^3 + 24x^2 + 6x + 1</samp>, and <samp>t = -(2^62 + 2^55 + 1)</samp>.</p>
<pre>
from hacspec.speclib import *

t = -(2**62 + 2**55 + 1)
p = lambda x: 36*x**4 + 36*x**3 + 24*x**2 + 6*x + 1
prime = p(t)

aBN256 = to_felem(0)
bBN256 = to_felem(1)

@typechecked
def map2BN256(u:felem_t) -&gt; affine_t:
    ZERO = to_felem(0)
    ONE = to_felem(1)
    SQRT_MINUS3 = fsqrt(to_felem(-3))
    ONE_SQRT3_DIV2 = fmul(finv(to_felem(2)),fsub(SQRT_MINUS3,ONE))

    fcurve = lambda x: fadd(fexp(x, 3), fadd(fmul(to_felem(aBN256), x), to_felem(bBN256)))
    flegendre = lambda x: fexp(u, (prime - 1) // 2)

    w = finv(fadd(fadd(fsqr(u),B),ONE))
    w = fmul(fmul(w,SQRT_MINUS3),u)
    e = flegendre(u)

    x1 = fsub(ONE_SQRT3_DIV2,fmul(u,w))
    fx1 = fcurve(x1)
    s1 = flegendre(fx1)
    if s1 == 1:
        y1 = fmul(fsqrt(fx1),e)
        return (x1,y1)

    x2 = fsub(ZERO,fadd(ONE,x1))
    fx2 = fcurve(x2)
    s2 = flegendre(fx2)
    if s2 == 1:
        y2 = fmul(fsqrt(fx2),e)
        return (x2,y2)

    x3 = fadd(finv(fsqr(w)),ONE)
    fx3 = fcurve(x3)
    y3 = fmul(fsqrt(fx3),e)
    return (x3,y3)
</pre>
<h1 id="rfc.appendix.C.6">
<a href="#rfc.appendix.C.6">C.6.</a> <a href="#elligator2-method" id="elligator2-method">Elligator2 Method</a>
</h1>
<p id="rfc.section.C.6.p.1">The following hacspec program implements map2curve_elligator2(alpha) for Curve25519.</p>
<pre>
from curve25519 import *
from hacspec.speclib import *

a25519 = to_felem(486662)
b25519 = to_felem(1)
u25519 = to_felem(2)

@typechecked
def f_25519(x:felem_t) -&gt; felem_t:
    return fadd(fmul(x, fsqr(x)), fadd(fmul(a25519, fsqr(x)), x))

@typechecked
def map2curve25519(r:felem_t) -&gt; felem_t:
    d = fsub(to_felem(p25519), fmul(a25519, finv(fadd(to_felem(1), fmul(u25519, fsqr(r))))))
    power = nat((p25519 - 1) // 2)
    e = fexp(f_25519(d), power)
    x = 0
    if e != 1:
        x = fsub(to_felem(-d), to_felem(a25519))
    else:
        x = d

    return x
</pre>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#test-vectors" id="test-vectors">Test Vectors</a>
</h1>
<p id="rfc.section.D.p.1">This section contains test vectors, generated from reference Sage code, for each map2curve variant and the hash2base function described in <a href="#hashtobase" class="xref">Section 4</a>.</p>
<h1 id="rfc.appendix.D.1">
<a href="#rfc.appendix.D.1">D.1.</a> <a href="#elligator2-to-curve25519" id="elligator2-to-curve25519">Elligator2 to Curve25519</a>
</h1>
<pre>
Input:

  alpha =

Intermediate values:

      u = 140876c725e59a161990918755b3eff6a9d5e75d69ea20f9a4ebcf
          94e69ff013
      v = 6a262de4dba3a094ceb2d307fd985a018f55d1c7dafa3416423b46
          2c8aaff893
     gv = 5dc09f578dca7bfffeac3ec4ad2792c9822cd1d881839e823d26cd
          338f6ddc3e

Output:

      x = 15d9d21b245c5f6b314d2cf80267a5fe70aa2e382505cbe9bdc4b9
          d375489a54
      y = 1f132cbbfbb17d3f80eba862a6fb437650775de0b86624f5a40d3e
          17739a07ff
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

      u = 10a97c83decb52945a72fe18511ac9741234de3fb62fa0fec399df
          5f390a6a21
      v = 6ff5b9893b26c0c8b68adb3d653b335a8e810b4abbdbc13348e828
          f74814f4c4
     gv = 2d1599d36275c36cabf334c07c62934e940c3248a9d275041f3724
          819d7e8b22

Output:

      x = 6ff5b9893b26c0c8b68adb3d653b335a8e810b4abbdbc13348e828
          f74814f4c4
      y = 55345d1e10a5fc1c56434494c47dcfa9c7983c07fcb908f7a38717
          ba869a2469
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

      u = 59c48eefc872abc09321ca7231ecd6c754c65244a86e6315e9e230
          716ed674d3
      v = 20392de0e96030c4a37cd6f650a86c6bc390bcec21919d9c544f35
          f2a2534b2b
     gv = 0951a0c55b92e231494695cb775a0653a23f41635e11f97168e231
          095dd5c30c

Output:

      x = 5fc6d21f169fcf3b5c832909af5793943c6f4313de6e6263abb0ca
          0d5da547bc
      y = 2b6bf1b3322717ed5640d04659757c8db6615c0dee954fbd695e8a
          c9d97e24d1
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

      u = 380619de15c80fe3668bac96be51b0fd17129f6cf084a250cfaa76
          7ff92b6cba
      v = 2f3d9063e573c522d8f20c752f15b114f810b53d880154e2f30cde
          fdf82bbe26
     gv = 4ce282b7cfdca2db63cec91a08b947f10fcf03bc69bafcd1c60b7d
          dfc305baaf

Output:

      x = 2f3d9063e573c522d8f20c752f15b114f810b53d880154e2f30cde
          fdf82bbe26
      y = 5e43ab6a0590c11547b910d06d37c96e4cc3fc91adf8a54494d74b
          12de6ae45d
</pre>
<h1 id="rfc.appendix.D.2">
<a href="#rfc.appendix.D.2">D.2.</a> <a href="#icart-to-p-384" id="icart-to-p-384">Icart to P-384</a>
</h1>
<pre>
Input:

  alpha =

Intermediate values:

     u  = 287d7ef77451ecd3c1c0428092a70b5ed870ca22681c81ac52037d
          a7e22a3657d3538fa5ce30488b8e5fb95eb58dda86
     u4 = 56aee47e1e72dbae15bd0d5a8462d0228a5db9093268639e1cd015
          4aa3e63d81eea72c2d5fa4998f7ca971bb50b44df6
     v  = eaa16e82d5a88ebb9ff1866640c34693d4de32fdca72921ed2fe4d
          cfce3b163dea8ec9e528f7e3b5ca3e27cba5c97db9
     x1 = cbc52f2bf7f194a47fd88e3fa4f68fc41cddeea8c47f79c225ad80
          455c4db0e5db47209754764929327edf339c19203b
     u6 = 5af8bcb067c1fc0bf3c7115481f3bd78afd70e035a9d067060c6e2
          164620d477e3247a55e514d0a790a7ddf58e7482fa
     x1 = 871a993757d3aa90b7261aa76fc1d74b8b4dcfbc8505f1170e3707
          1ab59c9c3a88caa9d6331730503d2b4f94a592b147

Output:

      x = b4e57fc7f87adbdc52ab843635313cdf5fb356550b6fbde5741f6b
          51b12b33a104bfe2c68bef24139332c7e213f145d5
      y = bd3980b713d51ac0f719b6cc045e2168717b74157f6fd0e36d4501
          3e2b5c7e0d70dacbb2fb826ad12d3f8a0dc5dc801f
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

     u  = 5584733e5ee080c9dbfa4a91c5c8da5552cce17c74fae9d28380e6
          623493df985a7827f02538929373de483477b23521
     u4 = 3f8451733c017a3e5acd8a310f5594ae539c74b009fc75aecda7f1
          abd42b3a47b1bd8b2b29eb3dd01db0a1bf67f5c15e
     v  = a20ff29b0a3d0067cb8a53e132753a46f598aa568efe00f9e286a5
          e4300c9010f58e3ed97b4b7b356347048f122ca2b8
     x1 = d8fcadbc05829f3d7d12493f8720514e2f125751f0dcf91ba8ee5d
          4e3456528c1e155cc93ac525562d9c3fcb3e49d3e3
     u6 = 35340edd3abbe78fe33fd955e9126d67c6352db6ecbcbcf3abbaa5
          30ffa37724d3a51d9d046057d0fa76278f916fa10c
     x1 = 382b470b52fbe5de86ed48a824ae3827a738b8cada54c9473d1eee
          18b548b8f12389dcea7c47893e18aafad06ab8ff52

Output:

      x = a15fe3979721e717f173c54d38882c011be02499d26a070a3bed82
          5fcac5a251a1297a9593254a50f8aa243c6191976a
      y = 641d1cb53087208240a935769ca1b99c3a97a492526e5b3cfae8c2
          0bebde9345c4dd549e2d01d5417918ce039451f4d7
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

     u  = d25e7c84dcdf5b32e8ff5ae510026628d7427b2341c9d885f753a9
          72b21e3c82881ab0a2845ec645dd9d6fd4f3c74cb3
     u4 = 60cbd41d32d7588ff3634655bd5e5ef6ab9077b7629bb648669cf8
          bef00c87b3c7c59bed55d6db75a59fc988ee84db41
     v  = f3e63b1b10195a28833f391d480df124be3c1cbbaa0c7b5b0252db
          405ba97a10d19a6afd134f1c829fd8fba36a3ea5a5
     x1 = 9d4c43b595deb99138eb0f7688695abe8a7145d4b8f1f911b8384b
          0205c873cfcb6a6092e71b887e0a56e8633987fa7e
     u6 = bb44318a26c920aa39270421eb8ff73aac89637d01e6b32697fbd2
          c6097d3143fbe8e192372a25be723a0008bcf64326
     x1 = aa283d625fdb4d127611e359d6bd6a2d1e63f036a2d9d1373c11d9
          1a557ffe24ec208f0408763c524112147fd78fd15e

Output:

      x = 26536b1be6480de4e8d3232e17312085d2fc5b4ad18aae3edfe1f6
          2c192ebcbed4711aba15be7af83ef691e09aded56c
      y = 7533cf819fa713699f4919f79fc0f01c9b632f2e08a5ae34de7d9e
          1069b18b256924b9acb7db85c707fb40ef893e4b9e
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

     u  = e1a5025e8e9b6776263767613cd90b685a46fe462c914aaf7dab3b
          2ac7b7f6479e6de0790858fae8471beda1d93117c2
     u4 = be47baa8671fb710a0cf58c85d95ea9cef2a7d6a6d859f3dbc52be
          fde3ad898851a83e166b87eeb7870ce1d3427a56b5
     v  = 24ed8cb050c045f6401a6221b85c37d482197f54a7340303449c13
          52717394450495f4bfa8c0bc12181496db59113671
     x1 = a1e180da2f619774632fccb74133963606ffaec0545dcdf225e180
          3f04d7bd9fb612bf57145004905142a35a5d1b47f0
     u6 = e806b407afd7874ad4ded43a46bc002e0dda1a39a5754cf09dfcb9
          9cfc8d19750a4a7e825e06ac256166b91ee3f5e28d
     x1 = 41d5d81708d776d643b75fd29658c14fddaf009d8f47a9ec18b9d3
          bee961f1544dd7339e6115bffbe638a17658cea94a

Output:

      x = 810096c7dec85367fa04f706c2e456334325202b9fcbc34970d9fd
          f545c507debc328246489e3c9a8d576b97e6e104d8
      y = ddde061cec66efc0cfcdabdc0241fdb00ab2ad28bf8e00dc0d45f8
          845c00b6e5c803b133c8deb31b4922d83649c4c249
</pre>
<h1 id="rfc.appendix.D.3">
<a href="#rfc.appendix.D.3">D.3.</a> <a href="#swu-to-p-256" id="swu-to-p-256">SWU to P-256</a>
</h1>
<pre>
Input:

  alpha =

Intermediate values:

      u = d8e1655d6562677a74be47c33ce9edcbefd5596653650e5758c8aa
          ab65a99db3
      v = 7764572395df002912b7cbb93c9c287f325b57afa1e7e82618ba57
          9b796e6ad1
     x1 = 7764572395df002912b7cbb93c9c287f325b57afa1e7e82618ba57
          9b796e6ad1
     gv = 0d8af0935d993caaefca7ef912e06415cbe7e00a93cca295237c66
          7f0cc2f941
    gx1 = 0d8af0935d993caaefca7ef912e06415cbe7e00a93cca295237c66
          7f0cc2f941
     n1 = ef66b409fa309a99e4dd4a1922711dea3899259d4a5947b3a0e3fe
          34efdfc0cf
     x2 = 2848af84de537f96c3629d93a78b37413a8b07c72248be8eac61fa
          a058cedf96
    gx2 = 3aeb1a6a81f78b9176847f84ab7987f361cb486846d4dbf3e45af2
          d9354fb36a
     x3 = 4331afd86e99e4fc7a3e5f0ca7b8a62c3c9f0146dac5f75b6990fe
          60b8293e8e
    gx3 = 1d78aa2bd9ff7c11c53807622c4d476ed67ab3c93206225ae437f0
          86ebaa2982
     y1 = 574e9564a28b9104b9dfb104a976f5f6a07c5c5b69e901e596df26
          e4f571e369

Output:

      x = 7764572395df002912b7cbb93c9c287f325b57afa1e7e82618ba57
          9b796e6ad1
      y = 574e9564a28b9104b9dfb104a976f5f6a07c5c5b69e901e596df26
          e4f571e369
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

      u = c4188ee0e554dae7aea559d04d45982d6b184eff86c4a910a43247
          44d6fb3c62
      v = 0e82c0c07eb17c24c84f4a83fdd6195c23f76d455ba7a8d5bc3f62
          0cee20caf9
     x1 = 0e82c0c07eb17c24c84f4a83fdd6195c23f76d455ba7a8d5bc3f62
          0cee20caf9
     gv = 4914f49c40cb5c561bfeded5762d4bbf652e236f890ae752ea1046
          0be2939c3a
    gx1 = 4914f49c40cb5c561bfeded5762d4bbf652e236f890ae752ea1046
          0be2939c3a
     n1 = ae5000e861347ff29e3368597174b1a0a04b9b08019f59936aa65f
          7e3176cf03
     x2 = 331a4d8dead257f3d36e239e9cfaeaaf6804354a5897da421db73a
          795c3f9af7
    gx2 = b3dda8702e046be4e2bd42e2c9f09fddbc98a3fe04bd91ca8a1904
          5684be9d81
     x3 = 1133498ac9e96b683271586be695ca43a946aa320eb32e79662476
          6ac7d1cc60
    gx3 = 7cd39b42a3b487dc6c2782a5aebd123502b9fecc849be21766c8a0
          0ca16c318f
     y2 = 6c6fa249077e13be24cf2cfab67dfcc8407a299e69c817785b8b9a
          23eecfe734

Output:

      x = 331a4d8dead257f3d36e239e9cfaeaaf6804354a5897da421db73a
          795c3f9af7
      y = 6c6fa249077e13be24cf2cfab67dfcc8407a299e69c817785b8b9a
          23eecfe734
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

      u = 777b56233c4bdb9fe7de8b046189d39e0b2c2add660221e7c4a2d4
          58c3034df2
      v = 51a60aedc0ade7769bd04a4a3241130e00c7adaa9a1f76f1e115f1
          d082902b02
     x1 = 51a60aedc0ade7769bd04a4a3241130e00c7adaa9a1f76f1e115f1
          d082902b02
     gv = f7ba284fd26c0cb7b678f71caecbd9bf88890ddba48b596927c70b
          f805ef5eba
    gx1 = f7ba284fd26c0cb7b678f71caecbd9bf88890ddba48b596927c70b
          f805ef5eba
     n1 = a437e699818d87069a6e4d5298f26f19fd301835eb33b0a3936e3b
          bd1507d680
     x2 = 7236d245e18dfd43dd756a2d048c6e491bb9ebfc2caa627e315d49
          b1e02957fc
    gx2 = 9d6ebf27637ca38ee894e5052b989021b7d76fa2b01053ce054295
          54a205c047
     x3 = 90553fadf8a170464497621e7f2ffcc35d17af4107b79dab6d2a12
          6ea692c9db
    gx3 = d7d141749e2e8e4b2253d4ef22e3ba7c7970e604e03b59277aed10
          32f02c1a11
     y1 = 4115534ea22d3b46a9c541a25e72b3f37a2ac7635a6bebb16ff504
          c3170fb69a

Output:

      x = 51a60aedc0ade7769bd04a4a3241130e00c7adaa9a1f76f1e115f1
          d082902b02
      y = 4115534ea22d3b46a9c541a25e72b3f37a2ac7635a6bebb16ff504
          c3170fb69a
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

      u = 87541ffa2efec46a38875330f66a6a53b99edce4e407e06cd0ccaf
          39f8208aa6
      v = 3dbb1902335f823df0d4fe0797456bfee25d0a2016ae6e357197c4
          122bf7e310
     x1 = 3dbb1902335f823df0d4fe0797456bfee25d0a2016ae6e357197c4
          122bf7e310
     gv = 2704056d76b889ce788ab5cc68fd932f3d7cb125d0dbe0afba9dd7
          655d0651ed
    gx1 = 2704056d76b889ce788ab5cc68fd932f3d7cb125d0dbe0afba9dd7
          655d0651ed
     n1 = 43b52359e2739c205b2e4c8a0b3cd6842feb2ed131ec37fc0788eb
          264dc1999b
     x2 = 39150bdb341015403c27154093cd0382d61d27dafe1dbe70836832
          23bc3e1b2a
    gx2 = 0985d428671b570b3c94dbaa2c4f160095db00a3d79b738ce488ca
          8b45971d03
     x3 = 30cf2e681176c3e50b36842e3ee7623ba0577f6a1a0572448ab5ba
          4bcf9c3d71
    gx3 = ea7c1f13e2ab39240d1d74e884f0878d21020fd73b7f4f84c7d9ad
          72d0d09ae0
     y2 = 71b6dea4bc8dcae3dab695b69f25a7dbdc4e00f4926407bad89a80
          ab12655340

Output:

      x = 39150bdb341015403c27154093cd0382d61d27dafe1dbe70836832
          23bc3e1b2a
      y = 71b6dea4bc8dcae3dab695b69f25a7dbdc4e00f4926407bad89a80
          ab12655340
</pre>
<h1 id="rfc.appendix.D.4">
<a href="#rfc.appendix.D.4">D.4.</a> <a href="#simple-swu-to-p-256" id="simple-swu-to-p-256">Simple SWU to P-256</a>
</h1>
<pre>
Input:

  alpha =

Intermediate values:

      u = 650354c1367c575b44d039f35a05f2201b3b3d2a93bf4ad6e5535b
          bb5838c24e
     n1 = 88d14bad9d79058c1427aa778892529b513234976ce84015c795f3
          b3c1860963
     x1 = c55836cadcb8cdfd9b9e345c88aa0af67db2d32e6e527de7a5b7a8
          59a3f6a2d3
    gx1 = 9104bf247de931541fedfd4a483ced90fd3ac32f4bbbb0de021a21
          f770fcc7ae
     x2 = 0243b55837314f184ed8eca38b733945ec124ffd079850de608c9d
          175aed9d29
    gx2 = 0f522f68139c6a8ff028c5c24536069441c3eae8a68d49939b2019
          0a87e2f170
     y2 = 29b59b5c656bfd740b3ea8efad626a01f072eb384f2db56903f67f
          e4fbb6ff82

Output:

      x = 0243b55837314f184ed8eca38b733945ec124ffd079850de608c9d
          175aed9d29
      y = 29b59b5c656bfd740b3ea8efad626a01f072eb384f2db56903f67f
          e4fbb6ff82
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

      u = 54acd0c1b3527a157432500fc3403b6f8a0aa0103d6966b783614a
          8e41c9c5b1
     n1 = bb27567ea0729adc2b7af65a85b7f599559b107ce0d2495c4d26d8
          a1ce842372
     x1 = 6ae899e0232f040f8a82934f462e1ccedac76ad8549ae581f17c82
          1a5944244f
    gx1 = 8a78bbf9c2156533fa0d9d37533752508a061b90108675ad705009
          7adabff9cb
     x2 = 498c0e2faee29adf4e6aed9120eb8c69cd3bb7206bcd47a746fb5e
          d4ed5529a5
    gx2 = 63adfce3aaa4d56b70cc3e8e7475154b5963855e275ffc26858cbf
          2456ea5f52
     y1 = 3b81976ce93e79d2ba13394a6b5deb34602d6829f4625d987fc98c
          a79d5d5c98

Output:

      x = 6ae899e0232f040f8a82934f462e1ccedac76ad8549ae581f17c82
          1a5944244f
      y = 3b81976ce93e79d2ba13394a6b5deb34602d6829f4625d987fc98c
          a79d5d5c98
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

      u = 86855e4bc3905ae04f6b284820856db6809633c5046ed92816a4e9
          976e994818
     n1 = 5ec1cf436c1a2e84b53674bcf2470a0aeeda9550c474b06da4bda8
          3bda56f2e3
     x1 = 04e73147d10de271f7d77a9a3d6dd761d5b892ab39224b9dab93a2
          50139b124a
    gx1 = 9d26bdc1b5afe7ccf9a7963a099e3c0b98070525b7ed08e8f32f44
          aef918b15f
     x2 = 28566b4d673bf59f00d42771968bd69b1a54e8b557857ba231cbdd
          feb18b38b5
    gx2 = 3b7edb432f00509ed44a4e6a2cbdbc69321215097953dac5bab8a9
          01a1d0d998
     y2 = 6644bab658f2915f2129791db0eb29eaeb34036db1bced721b161e
          06caaef008

Output:

      x = 28566b4d673bf59f00d42771968bd69b1a54e8b557857ba231cbdd
          feb18b38b5
      y = 6644bab658f2915f2129791db0eb29eaeb34036db1bced721b161e
          06caaef008
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

      u = 34a8fc904e2d40dabb826b914917a6feea97ec3c0828f41c8716b2
          6f8f4b7aaf
     n1 = 3b14efe9953378860e667b9051f9e412811e71b489ad8b72a8856f
          e57a5473d9
     x1 = 8ac342ff43931be5b1a9de4f602994853fa9ec943eacc5e39760df
          73fb4d9799
    gx1 = b45e916f6478943e1baf89e559c38f95457f2cadc1aaa8d54b0cac
          9507ebc6ba
     x2 = f9e15f7507632859104da82a28882021608b2c41f2fce3b1a82e43
          2841284ec7
    gx2 = 1940c3ff4cd98e41cdc5e863eb355168b5d794af03ca374244c7ac
          94c5e2f7b0
     y2 = 180369d261ec6086346e6b2d36990a3aaa803558f1398b6816c3c6
          18d41ff73e

Output:

      x = f9e15f7507632859104da82a28882021608b2c41f2fce3b1a82e43
          2841284ec7
      y = 180369d261ec6086346e6b2d36990a3aaa803558f1398b6816c3c6
          18d41ff73e
</pre>
<h1 id="rfc.appendix.D.5">
<a href="#rfc.appendix.D.5">D.5.</a> <a href="#boneh-franklin-to-p-503" id="boneh-franklin-to-p-503">Boneh-Franklin to P-503</a>
</h1>
<p id="rfc.section.D.5.p.1">The P-503 curve is a supersingular curve defined as <samp>y^2=x^3+1</samp> over <samp>GF(p)</samp>, where <samp>p = 2^250*3^159-1</samp>.</p>
<pre>
Input:

  alpha =

Intermediate values:

     u  = 198008fe3da9ee741c2ff07b9d4732df88a3cb98e8227b2cf49d55
          57aec1e61d1d29f460c6e4572b2baa21d2444d64d59cdcd2c0dfa2
          0144dfab7e92a83e00
     t0 = 1f6bb1854a1ff7db82b43c235727d998fe28889152ec4efa533994
          fc6d0e77cd9f3ddb8c46226de8e5de75f705370944b809fe0ca092
          8587addb9c54ae1a05
     t1 = 1f6bb1854a1ff7db82b43c235727d998fe28889152ec4efa533994
          fc6d0e77cd9f3ddb8c46226de8e5de75f705370944b809fe0ca092
          8587addb9c54ae1a04
      x = 04671bff33e7f9f7905848cd4c0fc652bd22200eedf29ef8e13ccb
          5536e4aa11db4366d2f346070d63c994bf0a4b1a4e555d6b3d021a
          eba340b641ada82054

Output:

      x = 04671bff33e7f9f7905848cd4c0fc652bd22200eedf29ef8e13ccb
          5536e4aa11db4366d2f346070d63c994bf0a4b1a4e555d6b3d021a
          eba340b641ada82054
      y = 198008fe3da9ee741c2ff07b9d4732df88a3cb98e8227b2cf49d55
          57aec1e61d1d29f460c6e4572b2baa21d2444d64d59cdcd2c0dfa2
          0144dfab7e92a83e00
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

     u  = 30e30a56d82cdca830f08d729ce909fc1ffec68df49ba75f9a1af7
          2ca242e92742f34b474a299bb452c6a71b69bdc9ee2403eaac7c84
          120a160737d667e29e
     t0 = 0a64d9f288a0881bb6addebc0db89f146b282b05570efa3419f5d3
          2f11ec7bb449a1da8b33817642f01db039f838ad0bd459ec03e76d
          8eec3a1e79d6c63f79
     t1 = 0a64d9f288a0881bb6addebc0db89f146b282b05570efa3419f5d3
          2f11ec7bb449a1da8b33817642f01db039f838ad0bd459ec03e76d
          8eec3a1e79d6c63f78
      x = 0970ff4bb9237704cc30f5b0d80a9d97001064ab4cdb98de74f8d7
          283b922726406393c07ad01de0499e46ebc0ed1cd116112cf8965f
          b8f918205adb13d3da

Output:

      x = 0970ff4bb9237704cc30f5b0d80a9d97001064ab4cdb98de74f8d7
          283b922726406393c07ad01de0499e46ebc0ed1cd116112cf8965f
          b8f918205adb13d3da
      y = 30e30a56d82cdca830f08d729ce909fc1ffec68df49ba75f9a1af7
          2ca242e92742f34b474a299bb452c6a71b69bdc9ee2403eaac7c84
          120a160737d667e29e
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

     u  = 3808ae24b17af9147bd16077e3e83aff5c579784c8a1443d90e5ff
          e2451bfabacba73ee8b8f652b991290f5c64b34b1a4c9a498e21d4
          3d000dae7f8860200a
     t0 = 2282d37dce4761dad69d1fe012c8580ba4e23158a0621fb3f51813
          10e7275e95573c89a8f0cda7ad98ca9e0a9e04ef94a1a79685d069
          6ac6ad423a0de96b7d
     t1 = 2282d37dce4761dad69d1fe012c8580ba4e23158a0621fb3f51813
          10e7275e95573c89a8f0cda7ad98ca9e0a9e04ef94a1a79685d069
          6ac6ad423a0de96b7c
      x = 173dc6d853d9024f367e24a283768e11ce559473e788f3c0ed0281
          6b48403fc6e100d4935b3f6197799bfbd4fbd94b3656596252f12b
          27fa46602c76ae1370

Output:

      x = 173dc6d853d9024f367e24a283768e11ce559473e788f3c0ed0281
          6b48403fc6e100d4935b3f6197799bfbd4fbd94b3656596252f12b
          27fa46602c76ae1370
      y = 3808ae24b17af9147bd16077e3e83aff5c579784c8a1443d90e5ff
          e2451bfabacba73ee8b8f652b991290f5c64b34b1a4c9a498e21d4
          3d000dae7f8860200a
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

     u  = 3ebdfccb07ddc61d9f81be2b9f5a7a8733581f1a8d531d78229d7b
          0be50f30887f085ef393422ef96e06ff1df4b608b05c53320a9012
          09b8df48b68ab338ec
     t0 = 27958e69b08a9fd2d1765ce3e8dbaf8645c28e5ce033b9d0a7875c
          e7e73d6583e62ff3a06a2b55de1cb8c26819d0cd4aed2dc7cb65fa
          d5eb3c149db9e8381b
     t1 = 27958e69b08a9fd2d1765ce3e8dbaf8645c28e5ce033b9d0a7875c
          e7e73d6583e62ff3a06a2b55de1cb8c26819d0cd4aed2dc7cb65fa
          d5eb3c149db9e8381a
      x = 3fe94cd4d2be061834d1a5020ca181562fdb7e9787f71965ca55cd
          dbf069b68ddd5e2b05a5696a061723093914e69b0540402baa0db3
          fddc517df4211daea1

Output:

      x = 3fe94cd4d2be061834d1a5020ca181562fdb7e9787f71965ca55cd
          dbf069b68ddd5e2b05a5696a061723093914e69b0540402baa0db3
          fddc517df4211daea1
      y = 3ebdfccb07ddc61d9f81be2b9f5a7a8733581f1a8d531d78229d7b
          0be50f30887f085ef393422ef96e06ff1df4b608b05c53320a9012
          09b8df48b68ab338ec
</pre>
<h1 id="rfc.appendix.D.6">
<a href="#rfc.appendix.D.6">D.6.</a> <a href="#fouque-tibouchi-to-bn256" id="fouque-tibouchi-to-bn256">Fouque-Tibouchi to BN256</a>
</h1>
<p id="rfc.section.D.6.p.1">An instance of a BN curve is defined as <samp>BN256: y^2=x^3+1</samp> over <samp>GF(p(t))</samp> such that</p>
<pre>
t = -(2^62 + 2^55 + 1).
p = 0x2523648240000001ba344d80000000086121000000000013a700000000000013
</pre>
<pre>
Input:

  alpha =

Intermediate values:

     u  = 1f6f2aceae3d9323ea64e9be00566f863cc1583385eaff6b01aed7
          a762b11122
     t0 = 1e9c884ab8d2015985a3e3d2764798b183ff5982b0fd9034f27456
          0f19d06ed0
     x1 = 0843eb0f5ed559e940a453f257b2a2e297895ecc2375a070168117
          b5127ec2ae
     x2 = 1cdf7972e12aa618798ff98da84d5d25c997a133dc8a5fa3907ee8
          4aed813d64
     x3 = 042f756fe42e2ed4c58990da3b2567a7b16252c0e17b2da55b8f68
          be71ebd432
      e = 2523648240000001ba344d80000000086121000000000013a70000
          0000000012
    fx1 = 0a8442855e93541a104052273e2bba930338d392d71f70efe83c77
          ae95471a4e
     y1 = 135a017a32abc542796e55d0b68840546c3b2498963773635e27c2
          5aa3737199

Output:

      x = 0843eb0f5ed559e940a453f257b2a2e297895ecc2375a070168117
          b5127ec2ae
      y = 135a017a32abc542796e55d0b68840546c3b2498963773635e27c2
          5aa3737199
</pre>
<pre>
Input:

  alpha = 00

Intermediate values:

     u  = 053c7251b0e5e5c9acde43c6abd44ffeb13109f61ec27ba0a8191f
          1165435065
     t0 = 0377baf027b80854661187280a98ae1320d7fd8cb0a65fd7077270
          6c38cb71d8
     x1 = 0f5173cd2eb8d4352497a9cb56ebf40b623d9dabb7dcc3f626b1f3
          89e49b9356
     x2 = 15d1f0b511472bcc959ca3b4a9140bfcfee3625448233c1d804e0c
          761b646cbc
     x3 = 100fb33cea2b98b99ca5a279e1b4e5b0cf6927ded3cb729a822483
          809e486dc7
      e = 2523648240000001ba344d80000000086121000000000013a70000
          0000000012
    fx1 = 044c88525cbf81408b9bac1c83bdc49e3f31ec5a7b68495b5d03e5
          18448a7f09
     y1 = 18e4bd91f687e110fb5f57411fccf34b4b1d16d3d978a75d988c38
          d338522d7c

Output:

      x = 0f5173cd2eb8d4352497a9cb56ebf40b623d9dabb7dcc3f626b1f3
          89e49b9356
      y = 18e4bd91f687e110fb5f57411fccf34b4b1d16d3d978a75d988c38
          d338522d7c
</pre>
<pre>
Input:

  alpha = ff

Intermediate values:

     u  = 077033c69096f00eb76446a64be88c7ae5f1921b977381a6f2e9a8
          336191e783
     t0 = 1716fb7790dd8e2e5a3ef94d63ca31682dd8b92ce13b93e0977943
          bf4c364c72
     x1 = 187ca1d0f0dec664467d49b4a4a661602faac5453fbd4ad9e3f15d
          a35627459e
     x2 = 0ca6c2b14f21399d73b703cb5b599ea831763abac042b539c30ea2
          5ca9d8ba74
     x3 = 0f694914de2533b1fbab6495b1de12cde6965bba0b505b527c1cb0
          69a5fdfd03
      e = 000000000000000000000000000000000000000000000000000000
          0000000001
    fx1 = 067a294268373f0123d95357d7d46c730277e67e68daf3a2c605bf
          035f680a7b
     y1 = 0de5f5d8ecfc19580a882c53c08b47791edf4499965df86263c525
          afd4fe0769

Output:

      x = 187ca1d0f0dec664467d49b4a4a661602faac5453fbd4ad9e3f15d
          a35627459e
      y = 0de5f5d8ecfc19580a882c53c08b47791edf4499965df86263c525
          afd4fe0769
</pre>
<pre>
Input:

  alpha = ff0011223344112233441122334411223344556677885566778855
          66778855667788

Intermediate values:

     u  = 1dd9ec37d5abeed0f289daddd685d45a395a90f2730a9adead62bf
          1ae2fe958b
     t0 = 23d0adbb23709a3732948019e038c13f498b33812149fe503b68da
          76831a7aca
     x1 = 00e2d073931bc2f38a069df42afbfc9e6f04155e52cf6211be3d40
          f4f4a3dc70
     x2 = 2440940eace43d0e302daf8bd5040369f21ceaa1ad309e01e8c2bf
          0b0b5c23a2
     x3 = 09c1ba4259e59a54221b5761cf9438a60e6cd644996e7c8a11be96
          88718e0261
      e = 2523648240000001ba344d80000000086121000000000013a70000
          0000000012
    fx1 = 080e2aef1644070acf09d6563db6805684572eb33f457d9d75ed5c
          f96e35c9c5
    fx2 = 0c2937174e6a4a89c1574ed4fa96d83a64fb09670c49a8b492321a
          edac6617f6
    fx3 = 118bcb595ca0eac3ae6e56595267670caf75d34386dadc99284bf8
          4ae4ff4804
     y3 = 190e8d47070240ff3c78a03d07123334e67b207fe555c31d0900fe
          71ab33035e

Output:

      x = 09c1ba4259e59a54221b5761cf9438a60e6cd644996e7c8a11be96
          88718e0261
      y = 190e8d47070240ff3c78a03d07123334e67b207fe555c31d0900fe
          71ab33035e
</pre>
<h1 id="rfc.appendix.D.7">
<a href="#rfc.appendix.D.7">D.7.</a> <a href="#sample-hash2base" id="sample-hash2base">Sample hash2base</a>
</h1>
<pre>
hash2base("H2C-Curve25519-SHA256-Elligator-Clear", 1234)
  = 1e10b542835e7b227c727bd0a7b2790f39ca1e09fc8538b3c70ef736cb1c298f

hash2base("H2C-P256-SHA512-SWU-", 1234)
  = 4fabef095423c97566bd28b70ee70fb4dd95acfeec076862f4e40981a6c9dd85

hash2base("H2C-P256-SHA512-SSWU-", 1234)
  = d6f685079d692e24ae13ab154684ae46c5311b78a704c6e11b2f44f4db4c6e47
</pre>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Armando Faz-Hernandez</span> 
	  <span class="n hidden">
		<span class="family-name">Faz-Hernandez</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:armfazh@cloudflare.com">armfazh@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Sam Scott</span> 
	  <span class="n hidden">
		<span class="family-name">Scott</span>
	  </span>
	</span>
	<span class="org vcardline">Cornell Tech</span>
	<span class="adr">
	  <span class="vcardline">2 West Loop Rd</span>

	  <span class="vcardline">
		<span class="locality">New York, New York 10044</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:sam.scott@cornell.edu">sam.scott@cornell.edu</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Sullivan</span> 
	  <span class="n hidden">
		<span class="family-name">Sullivan</span>
	  </span>
	</span>
	<span class="org vcardline">Cloudflare</span>
	<span class="adr">
	  <span class="vcardline">101 Townsend St</span>

	  <span class="vcardline">
		<span class="locality">San Francisco</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nick@cloudflare.com">nick@cloudflare.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">Apple Inc.</span>
	<span class="adr">
	  <span class="vcardline">One Apple Park Way</span>

	  <span class="vcardline">
		<span class="locality">Cupertino, California 95014</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">United States of America</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cawood@apple.com">cawood@apple.com</a></span>

  </address>
</div>

</body>
</html>
